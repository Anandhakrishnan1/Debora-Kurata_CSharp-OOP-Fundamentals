Course Overview
Course Overview
Hello. My name is Deborah Kurata, and I'd like to welcome you to my course, Object-Oriented Programming Fundamentals in C#. This course takes you on a journey through the principles, practices, and terminology of object-oriented programming. Along the way, we'll build a sample application with unit tests so you can code along or use it as a reference for your own development. Some of the major topics that we cover include identifying classes from requirements, separating responsibilities for focused classes, defining relationships between classes, and leveraging reuse through inheritance, interfaces, and polymorphism. By the end of this course, you'll know more about object-oriented concepts so you can better leverage the features of C# to build well-crafted and testable applications. Before beginning this course, you should be familiar with basic C# syntax and have some experience with Visual Studio. I hope you'll join me on this journey to learn object-oriented programming in C#, at Pluralsight.

Introduction
Introduction
C# is a modern, general purpose, object-oriented programming language. So the more you know about object-oriented programming concepts, the more you can leverage the features of C# to build well crafted and testable applications. Welcome to Object-Oriented Programming Fundamentals in C#, from Pluralsight. My name is Deborah Kurata, and this course takes you step by step through the principles and practices of object-oriented programming. The course provides you with a firm foundation in object-oriented programming to help you build production quality applications. Object-oriented programming is the foundation of many current application development approaches. Want to write clean code? The first step in writing clean code is to organize the code into appropriate classes using object-oriented programming techniques. Want to defend your code against errors both now and in the future? The first step in integrating defensive coding techniques is to organize the code into appropriate classes using object- oriented programming techniques. Want to use an iterative or agile approach to building your software? The first step is to organize the code into appropriate classes using object-oriented programming techniques. Need to build an API or application programming interface for your application? Yeah, if you are building a software product, management wants an API even though they probably don't know what it is. Every cool product now provides an API, right? The first step in building a good API is to organize the code into appropriate classes using object-oriented programming techniques. Want to understand and implement design patterns? Design patterns are based on object- oriented programming concepts. Want to use domain-driven design principles? Domain-driven design is based on object- oriented programming concepts. Want to build a cool .NET app? The first step in building any .NET application is to organize the code into appropriate classes using object-oriented programming techniques. So, understanding and using object-oriented programming techniques is the foundation of many other approaches, best practices, patterns, and architectures. Let's start our journey into object- oriented programming with a few definitions.

Object != Class
The two most basic words in object-oriented programming are object and class. Though they are often used interchangeably when speaking about object-oriented programming and when building applications, they are not the same thing. A class is code. Here is the beginning of a customer class. Notice the class keyword. It has properties such as EmailAddress and FirstName. The properties define the data managed by the class. The class also has functions such as Validate. The functions define the actions or behaviors managed by the class. In object-oriented programming, these functions are called methods. Together the properties and methods of a class define the class members. The basic purpose of a class is to provide the definition for a particular type of objects. This class defines objects of type Customer that can work with customer data and perform customer operations such as validating customer information. An object is an instance of a class. It is created using the C# new keyword. The syntax creates a new instance of the customer class. That instance is an object. This variable references the resulting object, hence, it is often called an object variable. The customer object represents a specific customer. Use the object variable to get or set any of the properties identified in the class. The object variable holds the state of the object, meaning, it retains the values of its properties and use the object variable to call any of the methods identified in the class. In this case, the Validate method is called for this specific customer object. When the application terminates, the object is gone. Any object state is gone unless it was stored somewhere such as in a database, but the class still exists because the class is defined in the code. A common metaphor for understanding class verses object is a cookie cutter. A class defines the properties and actions for all objects created from it like this cookie cutter defines a consistent size and shape. Use the cookie cutter to create instances, each of which is an object. Each object defines its own values for the properties just like cookies created from the cookie cutter can have different decorations. Mmmm, cookies. The main point to get from this metaphor is that the class provides the definition of the object type. It defines the properties and actions appropriate for the thing, in this case, heart-shaped cookie. Once you define a class, you can create any number of unique objects from the class. Each object is created as an instance of the class and has its own values for the properties. In this example, different decorations. So each cookie has the same object type, heart-shaped cookie, but different values. What about other related terms such as business objects and entity?

Terms in Context
You may hear something like, we need to define the business objects. Confusingly, the term business object normally refers to a class. In most cases, it refers to classes defined specifically for solving a business problem like our customer class here. So the customer class could be referred to as a business object. Used in this context, a business object is not an object at all, it is a class. So an object is not a class, but a business object often does refer to a class. Yeah, this seems inconsistent to me too. When identifying and designing classes, it doesn't really matter what we call them as long as it's clear that once we start coding, we are building classes. Let's talk about one more term at this point. Entity. We just said that a class defines the properties and actions appropriate for the thing, in that case the heart-shaped cookie. Calling each of the things we want to create a class for, things is a little imprecise. A common term is to use entity. This same term is used in the same context and database design to define the things that are significant enough to consider. Same here. Anything from the real world that is significant enough to be represented as a class in the application is referred to as an entity. Note that this use of the term entity has nothing to do with Entity Framework, though Entity Framework also uses the term entity to define the significant things. Putting the terms together, say we are building a customer management system. From the name of the system, we would expect customer would be an entity. It is important enough to consider as a class. After some analysis, we determine that there should indeed be a customer class. And it has first name and last name properties, and a Go On An Adventure method. When executing the application, the user may request all customers with a last name that starts with Bag. So the application may create two instances of the customer class; one for Bilbo Baggins and one for Frodo Baggins. These are our two objects created from the class. Bilbo and Frodo are both customer objects. They are instances of the customer class. And either one, or both, can execute the Go On An Adventure method. Now that we know the difference between an object and a class, let's define object- oriented programming.

What Is Object-oriented Programming?
What is object-oriented programming, or OOP as some people call it? Object-oriented programming is an approach to designing and building applications that are flexible, natural, well-crafted, and testable by focusing on objects that interact cleanly with one another. To build an application following object- oriented programming techniques, start by identifying the classes from the requirements or specification. Object-oriented programming represents the entities and concepts of an application as a set of classes. Next, analyze the identified classes and separate responsibilities as needed. Object-oriented programming focuses on logically separating the responsibilities of the application into classes. The idea is that an application should be decomposed into parts with minimal overlap. If each class has a singular purpose, it is easier to write, test, and later find that class to update or extend it. That makes the code easier to modify and adapt to new requirements and future demands. This is sometimes called the principle of separation of concerns. No class is an island. No class stands on its own. Object-oriented programming involves understanding the relationships between the classes. These relationships define how the objects created from those classes work together to perform the operations of the application. One of the key goals of object-oriented programming is reuse. By extracting commonality among a set of classes into a separate class, our code is more reusable. Extensive reuse of existing proven classes shortens development time and leads to more robust applications. This course walks you through each of these tasks. Though shown here as a set of steps, object-oriented programming is an iterative process. You may identify a few classes, look at separating out some responsibilities, and then find you need to identify more classes. You may define some relationships and find you need to separate out more responsibilities, and so on. We're covering a lot. Let's look at ways to get the most from this course.

Get the Most from This Course
First, the prerequisites. To get the most from this course, it is important that you minimally know the basics of C#. This means understanding basic C# syntax, variables, conditionals, and control flow. If you don't have the requisite knowledge, consider viewing one of the C# Fundamentals courses in the Pluralsight library. It is also suggested that you have experience with Visual Studio as we will be using it to build our classes and our unit tests. If not, consider viewing one of the Introduction to Visual Studio courses in the Pluralsight library. You do not need object-oriented programming experience. We'll cover what you need in this course. If you know some C# and are comfortable with Visual Studio, you are ready to go. When building applications, there are often lots of steps and places where things can go wrong. That's when a good checklist can come in. I'll present checklists at the end of many of the modules, and we'll use them as a brief review of what was covered in that module. Feel free to jump ahead to the checklist if you have problems when coding along with the demos. And consider referencing these checklists as you start implementing your own object- oriented applications. Coding along through the demos is another great way to get the most from this course. Though not required, it is often helpful to try out the presented techniques. Now let's finish up this introductory module with a look at the outline for the remainder of this course.

Course Outline
This course takes you through the process of building object-oriented code in C# by stepping through each object-oriented programming task. Most projects start with some words. This course begins by walking through how to turn those words into a set of well-defined classes. Then we'll build those classes using C# and write some simple unit tests to test those classes. Next, we separate out some of the responsibilities of those classes into additional classes and modify the code accordingly. Then we look at how to establish relationships between the classes and change the code to implement those relationships. The relationships define how the objects from those classes work together to perform the operations of the application. The power of object-oriented programming lies in its promise of reuse. We look at techniques for leveraging reuse using object-oriented programming techniques. We'll modify the code to build a reusable class, and then, of course, reuse it. We'll take reuse a step further and build a reusable component as well. Lastly, we look at defining and using interfaces. Interfaces are an integral part of the .NET Framework and are used in many design patterns. When you've finished this course, you will have a firm foundation in the object-oriented programming principles and practices. You will have the knowledge to build production quality applications, and you will be ready to successfully advance to intermediate level C# courses. The more you know about object-oriented programming concepts, the more you can leverage the features of C# to build flexible, well-crafted, and testable applications. Let's get started.

Identifying Classes from Requirements
Introduction
Regardless of the formality of your development process, every project starts with some words. Can you build a customer management system to help us track our customers and orders? Or maybe just we need to change the system to track different types of products. Welcome back to Object-Orienting Programming Fundamentals in C#, from Pluralsight. My name is Deborah Kurata, and this module shows you how to extract classes from words as a first step in building an object- oriented application. This module takes you step by step from business requirements through to an initial set of classes that address those business requirements. We first analyze the business problem starting with the nouns to identify appropriate classes. Then, define an initial set of class members, that is, the set of properties and methods for each of those classes. Along the way, we identify two of the four pillars, or key characteristics, of object-oriented programming, abstraction and encapsulation. Note that some literature includes only three pillars of object-oriented programming, skipping abstraction. That's because abstraction is more of a concept, the way to think about your classes, and not a programming technique. This will become clear as we define our abstractions later in this module. Although the example used in this course builds a new application, all the principles, practices, and techniques we cover are equally applicable when implementing new features or making enhancements to existing applications. Now let's get to that imaginary meeting with the subject matter experts so we can collect our requirements and get started.

Analyze the Business Problem
You've been given a feature request, or a business problem statement, or a specification, or maybe just a brief email, and you are expected to turn those words into code, and not just any code, but code that is clean, defended, manageable, maintainable, extensible, and testable. Where do you start? The first step to building an object- oriented application is to identify the classes. So let's start there. Let's take a look at the specification change request, or email, that we were given using it to identify the initial set of classes that represent the business entities, and then define the appropriate properties and methods. You are called into a meeting with one of the department heads and her staff. They will be your subject matter experts for collecting the requirements. One of the subject matter experts says, thank you for meeting with us today. Our current customer management system is not able to handle our increasing numbers of customers and orders, so we would like you to build a new system for us. The subject matter expert continues. We are calling it the Acme Customer Management System. The new system must manage business, residential, government, and educator types of customers. It must manage our products and accept orders from customers either online or through our call center. No problem, you say, or something to that effect. Okay, this particular business problem is a little overly simplified, but it defines a business component that we can build within the timeframe of this course, and it is complex enough to demonstrate key object-oriented programming principles. Let's analyze the requirements we were given.

Start with the Nouns
When extracting classes from words, the easiest place to start is with the nouns. A noun is a person, place, thing, or process. Look at each noun defined in the requirements and determine whether it should be represented as a class. Looking at the first requirement, manage business, residential, government, and educator types of customers, the noun that sticks out is customer. From the second requirement, manage our products, the noun is product. The third requirement, accept orders from customers online or through our call center, includes several nouns, but the important one for our purposes is order. In this case, each requirement identified one class. That may not always be the case. Some requirements may identify multiple classes or no classes at all. This step results in our first cut of classes. The Customer class manages the business, residential, government, and educator customers. The Product class manages our current products. And the Order class manages orders received online or from the call center. Next, we identity appropriate properties and methods for each class.

Define Appropriate Members
The members of a class define the properties, or data, the class requires and the methods, or operations, that an object from the class can perform. We again use the requirements as a starting point to define the appropriate members for each class. Let's begin with the class properties. To manage the customers, we must minimally track the customer's name, last name, first name, email address, and home and work addresses. To manage products, we should track the product name, description, and current price. And to handle the orders, we must track the customer, order date, shipping address, and the products and quantities ordered. With the properties defined, here are our classes so far. Our customer class manages the customer properties. The product class defines the product properties, and the order class tracks the order properties. Wait, what? This isn't right. Using the nouns to determine the initial set of classes is helpful, but it only provides a starting point. Looking at the properties and methods for each class helps clarify the design and often illustrates other potential classes. In this case, we need to track the customer, order date, and shipping address for the order, and then each product and quantity ordered. It wouldn't make sense to require a separate order for each ordered product. It sounds like we need another class, Order Item. The order then has a set of order items specifying the product and quantity. Now that we have the properties, what about the methods? We'll need some basic methods in each of the classes, Validate to ensure valid information is entered, Retrieve to retrieve existing data from a data store such as a database, and Save to save entered or changed data back to that data store. The methods define the operation's actions and behaviors appropriate for the class, hence, methods are named using a verb. Each object instantiated from the class can perform the operations. That's it. We have our initial set of classes along with their properties and methods. There is one more thing to think about at this stage. The fourth dimension, time.

Consider Time
It's easier to think about the list of classes and their members at one point in time. But the resulting application will need to work for several years or more. During that time, data will change. Customers move, product prices are updated, and so on. Let's take a moment to think about our classes and members over time. Over time, the customer's data may change. Their email address, their addresses, and even their name. It's important to think about whether the application cares about these changes or needs to track historical information. Notice how the order has a property of its own for the shipping address. This ensures that the shipping address is retained over time, regardless of changes made to the customer's addresses. If the customer has an updated address, the order retains the address the order was originally shipped to for historical reference. Looking at the product, how will its data change over time, and how will that affect the order? Can the product price be updated? That would be problematic. Consider this scenario; customer Joe places an order for a new keyboard. His order comes to 49.95. The staff then changes the price to 59.95. Since the order item is simply referencing the product, when Joe gets an email of his order a few minutes later, the price is now 59.95. That would make for one unhappy customer. How do we deal with these data changes over time? One option is to track the purchase price in the order item. That ensures that the price given when the order is placed is the purchase price regardless of changes to the product data over time. It is always a good idea to take a moment and consider how time affects your classes and members, and add classes or members as needed to ensure your classes stand the test of time. Speaking of time, now is a good time to introduce two more terms; abstraction and encapsulation.

Abstraction
From the list of requirements, we identified Customer as a class, but what is a customer in the context of our application? Joe Smith is a customer. Joe is the CEO of Smith Incorporated. He's married, has two children, and a dog. He takes the metro to work every day and goes out to lunch on Fridays. For the purpose of this customer management system, the majority of this information is irrelevant. We can abstract it away and focus only on the features of the customer appropriate for our application. For our case, we only care about a customer's name and contact information. That helps us to simplify reality and think of customer just in terms of a contact. If we were building a system that sent emails about products that Joe might like, then we could define a different abstraction for our customer that included more personal information. Or if we were building a personal assistant, we might define an abstraction that included Joe's family and how he gets to work. The appropriate abstractions depend on the requirements of the application. Abstraction is the process of defining classes by simplifying reality, ignoring extraneous details, and focusing on what is important for a purpose. It involves abstracting away the extraneous details in order to focus on what is relevant for the particular application. Defining appropriate abstractions is considered one of the pillars, or key characteristics, of object-oriented programming.

Encapsulation
Another pillar of object-oriented programming is encapsulation. Unlike abstraction, which is a concept, basically a way to think, encapsulation is a technique. Encapsulation is a way to hide or encapsulate the data and implementation details within a class, thus hiding complexity. This large circle represents a class, specifically the customer class. The data field's name, email, home address, and work address are all hidden within the class. No other code can access these data fields. The code for the operations such as the validate, retrieve, and save is also hidden within the class. No other code can just jump into this code. The benefit of hiding this data and implementation is that no other code in the application needs to know about these details. In C#, the object data is exposed to the application through property getters and setters. The operations are exposed to the application through methods. The exposed set of methods and property getters and setters define the class interface to the rest of the application. We'll talk more about interfaces later in this course. If the UI, for example, wants to access the property such as the name, it must call the getter or setter. The getter retrieves the value of the private data, optionally manipulates that data, and returns it. The setter optionally validates the incoming value, and if valid, updates the private data. We'll see this in action in the next module. Any code that wants to perform an operation using the code within the class, must call the methods. Encapsulation is a key underlying principle that makes it possible to build large, full-featured systems by breaking complex operations into encapsulated units. These encapsulated units are classes. Encapsulation allows the objects in an application to work together without each object knowing the details of other object's implementation. Encapsulation hides both the data and implementation within the class. This data hiding has many benefits. It protects the data. No other code can modify the underlying data except through the getters and setters. This prevents an object's values from being corrupted by other objects. We can add code to the getter to perform operations before the data is provided. For example, we could ensure the user has access to the specific data element. We can add code to the setter to perform operations before the data is set. For example, we could provide validation so that the data is never set to an invalid value. Hiding the method implementation details also has benefits. It helps to manage the complexity of the application by breaking it down into manageable units. It shields the other objects from having to know the implementation details. Only the class needs to understand the implementation. The code is easier to modify and test because the implementation is encapsulated in one place. Because of this, the implementation can be changed, as needed, without impacting the rest of the application. The real world works like this as well. For example, if you go to Amazon and order a product, you don't need to know anything about where or how your product is stored or how your order is processed. By building classes with properties and methods, we encapsulate the logic for each entity within one unit of code.

Summary
In this module, we saw how to use the set of words from the requirement specification, whatever its form, to identify the initial set of classes for an application. We walked through how to analyze the business problem. Start with the nouns to identify the entities and determine which entities should be implemented as classes. Define the appropriate members, which are the properties and methods of each class. Identify each role of a data element as a property and each required action or behavior as a method. And don't forget to consider the effect of time. For example, adding a shipping address to an order may seem like duplicating data, but it allows the customer data to change over time while retaining the order data at a specific point in time. Along the way, we define two of the four pillars of object-oriented programming. Abstraction describes an entity in simple terms, ignoring the irrelevant details. It reduces complexity by focusing only on what is important for the purpose of this specific application. And encapsulation, which allows for hiding the data and the implementation within the class. We'll see encapsulation in action in the next module. We've taken the first step in the journey toward an object-oriented application by using the requirements to identify the initial set of classes, their properties, and their methods. Before moving on, let's see how to implement what we have so far in C#.

Building Entity Classes
Introduction
Now that we've defined a set of classes for our basic entities, let's build them. Welcome back to Object-Oriented Programming Fundamentals in C#, from Pluralsight. My name is Deborah Kurata, and this module demonstrates how to build classes. Recall the classes we identified so far in this course; Customer, Product, Order, and Order Item. This module provides step- by-step demonstrations showing you how to create and test one of these entity classes. The others are created later in this course using the same techniques. But before we can build the classes, we need to lay out the structure of the application.

Layering the Application
Most applications today are built with a layered structure. Though not specifically an object-oriented programming concept, layering is key to defining a good application structure. That structure is then defined in Visual Studio using a solution for the application and a project for each layer. Most applications are minimally divided into three layers. The user interface layer is where we create the forms, or pages, that are displayed to the user. It includes any logic required to control and populate the user interface elements. The business logic layer is where most of the application logic resides, including the logic to perform the business operations. The design we have so far in this course will be implemented in the business logic layer. And a data access layer that contains the code to retrieve data from the database or other data store and save data back to that data store. If you use Entity Framework, this is where the Entity Framework code resides. Some applications have additional layers, depending on the complexity and design of the application. Though it's not really a layer, many applications include a common library for general purpose code that's useful throughout the application. That can include code for features such as logging or sending an email. Each of the layers and the common library are defined as a separate project within a Visual Studio solution. When the code in each project is built, Visual Studio creates an appropriate component. The user interface project might compile to an exe. The remaining layers are created as class libraries and compiled to DLLs. Dividing an application into layers makes it easier to work with each layer and easier to extend the application. By having the business logic separate from the user interface, we could later add a web user interface onto a desktop application without reworking or rewriting any of the business logic. Now we are ready to start building our application.

Building the Business Logic Layer Component
The classes we have identified so far in this course will contain the data and processing required for the business logic. So let's start by building our business logic component. I've just opened Visual Studio. I am using Visual Studio 2017 Enterprise edition, but you can use any edition of Visual Studio, including the free Express edition. Start by creating a new project. Click Create new project on the start page or File, New, Project from the menu. Then, select the project template. First, pick the desired language on the left. Everything you see in this course can be done with VB or C#, but we'll use C#. On the right, select the template. Since we are building the project for the business logic, we want the template for our Class Library. We'll stick to the .NET Framework Class Library for our purposes. We are building the Acme Customer Management System business layer, so we'll name the project ACM, for Acme Customer Management, .BL for business layer. I'll pick my desired location. And since the solution will hold all of the projects for this application, we'll name it just ACM. Visual Studio then creates the solution and project and displays it in Solution Explorer. It also creates a default class for us. Looks like we are ready to write some code.

Building a Class: Properties
In this demo, we build the customer class and add some of its properties. Now that we created the business layer project, we can add the entity classes to that project. Let's start with the customer class. We could delete Class1 and add our customer class from scratch, or we can simply rename Class1. If we rename Class1 in Solution Explorer to Customer, it provides an option to automatically rename the class in the code file. Let's do that. By default, a class is private and not accessible to any other code. The public keyword gives the class public accessibility. That means that the class is callable from any other part of the application. We want other layers to use these entity classes, so we want them to have public accessibility. We now have a Customer class. Each class we define is a type. Just like strings are types and integers are types, our classes are types. We've identified several properties for the Customer class, including a name property. We could define a name property here. In most cases, when building a class that represents a person, the name is divided into two separate properties; FirstName and LastName, and if necessary, middle name or initial. This gives us more flexibility in working with and displaying the name. Let's define a property for the first and last name. Recall from the last module, a class should encapsulate its data. That means that the actual data is hidden within the class, and access to that data is provided with accessors. In code, the data is hidden by defining a private backing field. This field holds the data, and it uses a private access modifier to ensure that no code outside of this class can access it. The data is accessible to other parts of the application through a C# property. I'll paste the code, and we can talk through it. A property is often defined with a public access modifier, meaning any code can use it to get or set the data. If we want the property to only be accessed within the current project, meaning our business logic layer, we can use the internal access modifier instead. Internal means that access is limited to code internal to the project in which it is defined. Code in any other project such as the user interface layer could not access the property. In this case, we do want this property to be public. A property includes a get accessor, or getter, and a set accessor, or setter. As its name implies, the get accessor gets the property value. In this example, the code returns the value of the backing field. We can add code in the get accessor to perform any operations prior to returning the value such as verifying that the user can access this data or reformatting or converting the data. For example, if this was returning a price, it could return it in the appropriate currency for the user's country. Leave off the getter entirely to define a write-only property. The set accessor sets the property value. In this example, the code simply assigns the value to the backing field. We can add code in the set accessor to perform any operations prior to assigning the value such as validating the value before assigning it or reformatting or converting the data. Leave off the setter to define a read-only property. We'll see examples of how these properties are called a little later in this module. Every time we define a property, declare a private variable to hold the value. That variable is the backing field, and add a C# property with get and set accessors. In many cases, there is no need for code in the getter or setter. When that is the case, we can shortcut the property syntax using something called auto implemented properties. Let's define the FirstName using the shortcut syntax. Notice how much shorter that syntax is, but where's the backing field. Behind the scenes, the code is still creating a backing field, we just don't have to manage it. We get the benefits of encapsulation without the extra code. How do you decide when to use which? If there is no need for logic within the getter or setter, use an auto implemented property, otherwise, use the full property syntax. But there are other ways to create properties.

Using Snippets
Let's take a moment and talk about snippets. Visual Studio provides a set of snippets, which are pre-built pieces of code. We can use snippets to help us build our classes. Let's add an email address property using a snippet. To use a snippet in Visual Studio, use Edit, IntelliSense, Insert Snippet from the menu, or right-click Snippet, Insert Snippet. Double-click the appropriate category, then locate the desired snippet. We want a property snippet, so scroll to prop. Notice that the tooltip describes the snippet and provides its shortcut name. Consider memorizing the shortcut name for any snippets you plan to use often. Notice there is prop to generate an auto implemented property, propfull to generate a full property with its backing field, and propg to generate a public getter with a private setter. We want an auto implemented property, so double-click to select the snippet. The highlighted areas are called replacements. Replace the value and press Tab to move to the next replacement. We want an email address property, so type string, Tab to close the list, Tab to move to the next replacement, EmailAddress for the property name, and Enter to complete the replacements. This makes it quick to add auto implemented properties to a class. Even though the specification didn't call for it, we know we'll want a unique identifier for each customer, so let's add a customer ID property. In this case, we want to allow getting the ID, but never setting it. The database will set the ID. Let's use propg, Tab, Tab. We'll keep the type as int, Tab, and name it CustomerId, Enter. Any caller can then get this ID, but only this class can set it. Looking again at the Visual C# snippets, there are snippets available for many common tasks. Try them out. Let's skip the postal address fields for now. We'll deal with those later, but before we move on, let's create one more property. The original specification called for a name property with LastName, FirstName. Let's add a FullName property that returns the format required by the specification. We don't need a backing field because it doesn't require holding any additional data. The LastName and FirstName already take care of that, and we don't need a setter. No other code should change this value. Instead, code would change the LastName or FirstName properties directly. In the getter, we return the FullName in the appropriate format; LastName, FirstName. Now that we have our first set of logic in our application, let's write our first unit test.

Testing the Class
We are building our business layer independent from any user interface. How are we going to try it out? We can't run a DLL component. The best way to try out our code is to write a unit test. A unit test is another piece of code whose sole purpose is to test a particular unit, or piece of our code. We normally write unit tests for each property and method in our class. These often include tests with valid values, tests with invalid values, and tests for any corner cases. In this example, we test the FullName property. This is the test with valid values. We could also write tests for invalid values such as null or empty first or last name. There are several common techniques for organizing the code in a unit test. I use the Arrange, Act, Assert structure. In the Arrange section, we set up for our test. In this example, we create an instance of the class using the new keyword. We then use that instance to set test data in the properties. Lastly, we define the expected result of the test. In the Act section, we access the property or method we are testing. In the Assert section, we determine if our test was successful. We use the .NET Assert class to assert that our expected value and our actual value are equal. If they are equal, the test passes, otherwise, it fails. For a more detailed introduction to unit testing in Visual Studio, including test naming and structure guidelines, see Defensive Coding in C# in the Pluralsight library. Now let's give testing a try.

Testing the Class: Valid Values
In this demo, we'll write a unit test to test our code using valid values. In Visual Studio, we create our unit tests in a separate project. To keep things organized, let's put the unit test in a separate folder. Right-click on the Solution in Solution Explorer, and select to Add a New Solution Folder. We'll name that folder Tests. Note that this adds a folder grouping to our solution, but not in our system directory structure. Then we create the test project in that folder, right-click on the folder, and select Add, New Project. On the left side of the dialog, select the appropriate language and Test. Then select Unit Test Project. I normally name my test project the same as the component it is testing with the test suffix, ACM.BLTest. To create the test in a new system folder, add /Test to the location path. Click OK, and Visual Studio creates a basic UnitTest class and unit TestMethod. Before we can test our class, we need to reference it from the test project. Under the Unit Test Project, right-click on References, and select Add Reference. On the left side, select Projects, and check ACM.BL, our business layer project we are testing. Our test project now has access to the classes in our business layer project so I can test them. Now we are ready to write our test. Rename the generated test file in Solution Explorer to the name of the class we are testing with a test suffix; CustomerTest, and select to rename the class as well. Once the class is in place, we can add a method to the class for each test we wish to perform on that class. As we saw in the slides, the first test we want to write is one to test the FullName property with valid values. Rename the generated TestMethod to describe the test, FullNameTestValid. We'll use the Arrange, Act, Assert structure for the test. In the Arrange section, we create an instance of the customer class. The customer class we created is a type, so we declare a variable of that type. That defines the object variable that will reference our object. The code is showing an error because we are missing the using statement. Use the quick action to insert the appropriate using. The using statement specifies that code in this file will access the BL component. Next, we want a new instance of the class, so we use the new keyword and the name of the class. This line of code creates an instance of the customer class and assigns it to an object variable defined as type Customer. Now we use the object variable to set the FirstName property to a test value and set the LastName property to another test value. Notice that we are getting a quick action suggestion. Click it, and we see Object initialization can be simplified. There is a shortcut syntax for creating an instance of an object and assigning property values in one statement. This syntax is called an object initializer. Let's use that. Click on the action to apply it. Lastly, we define the expected value. In the Act section, we perform the operation we are testing. In this test, we get the value of the FullName property. In the Assert section, we verify that the expected value equals the actual value. Now we are ready to run the test. Do you think it will pass? You may have already noticed the error that we made when defining a FullName property. Well, let's run our test anyway and see how it shows us our error. First, open the Test Explorer, Test, Windows, Test Explorer. It displays the list of tests and the results of those tests. Pin the window so it stays on the screen. We can run the test from Test Explorer, or right-click on the test itself and select Run Tests. Visual Studio first builds the solution, then shows the result of the test in the Test Explorer. Navigate down to the test to view execution details. Hmmm, expected Baggins, Bilbo, actual Baggins, Bilbo. Ah, we forgot a space. Let's fix that. Going back to the Customer class, we need a space after the comma. Run the test again, and everything is green, it passes.

Testing the Class: Invalid Values
As much as we'd like our users to always put in valid values, the reality is, they don't. So our code needs to take precautions and handle invalid scenarios. In this demo, we'll write a unit test to ensure our class gracefully handles invalid values. Let's add another test for our FullName property. This time with invalid values. First, let's try leaving the FirstName empty. I'll paste the code. It looks similar to our prior test, but notice we are defining only the LastName here, and expect the FullName to be the LastName with no comma. Then let's write another test leaving the LastName empty. In this case, we expect to get the FirstName with no comma. We have no code for special handling of the comma, so I'm betting these will fail. Again, open the Test Explorer, pin it, and select to Run All. Yep, the test for invalid values fail. Clicking on the test, we can see that our code adds a comma even if there is no FirstName and if the LastName is missing. Going back to the Customer class, let's update the FullName code to better handle null or empty values. Now if there is only a LastName defined, the FullName is the LastName with no commas. If there is only a FirstName, the FullName is initially null, so we set the fullName to the FirstName. If there is both a LastName and a FirstName, we start with the LastName, add a comma, and a space before appending the FirstName. Try the test one more time, Run All, they pass. By using unit testing, we can check our code as we go while we remember its details even if there is no user interface built yet, and ensure our code handles both valid and invalid values. Our test also gave us some practice using object variables. Before we move on, let's talk a bit more about working with objects.

Working with Objects
Working with objects can seem a bit strange at first. Let's review how to create a new object. An object is created using the new keyword, followed by the type of object to create, and parenthesis. This example creates a new instance from the Customer class. Assign the resulting object to an object variable. The type of the object variable is the type of the created object. The object variable then holds a reference to that newly created instance. When defining local object variables, instead of declaring a specific type, use the var keyword. Var defines an implicitly-typed variable. An implicitly-typed variable is strongly typed just as if it were declared with a specific type. Using var shortens the syntax and can make the code easier to read in cases where the type is obvious. Here we are obviously creating an object of type customer. Once we have an object variable, we use it to access the class properties. Here is the Customer class similar to how we have it so far. We use the full property syntax for the LastName property and auto implemented properties for the CustomerId, EmailAddress, and FirstName. For the FullName, we defined a read-only property by defining a getter with no setter. Assign a value to a property with an equal sign just like assigning a value to a variable. Assigning a value to the property executes the setter. This example assigns the value of the backing field to Baggins. Use the same syntax to set the FirstName. Even though this property uses the auto implemented property syntax, assigning to the property still executes the setter and sets the value of the hidden backing field to Bilbo. Get the value of the property by simply referencing it, and it executes the getter. This example returns the FullName of Baggins, Bilbo. But working with objects can get a bit more complex.

Objects Are Reference Types
Objects are reference types, meaning that they hold a reference to their data, not the data itself. This is different than value types such as integers that hold their data directly. Why does this matter? Well, here's a little quiz. In this first case, we declare an integer i1, and set it to 42. Then, define a second integer i2, and set it equal to i1. Now for the tricky part, set i2 equal to 2. What it i1 at this point? To find the answer, let's talk through that again. We declare i1 and set it to 42. Then we declare i2 and set it equal to i1, which copies the value of 42. Then we change i2 to be 2, so what is i1 at this point? It's still 42, but now let's look at what happens when we do something similar with reference types. Declare a new customer, c1, set c1's FirstName to Bilbo, then declare a second customer, c2, and set it equal to c1. Then change c2's FirstName to Frodo. What is c1.FirstName? Let's talk through that again. First, we declare c1. It's referencing a new customer. We set the FirstName for that customer to Bilbo. Then we create a second object variable, c2, and reference that same customer. At this point, since they are reference types, both c1 and c2 are referencing the same customer. So if we change c2's FirstName to Frodo, what is c1.FirstName? It is also Frodo because they are both pointing to the same customer. It is important to remember how reference types work as you create and manipulate objects. But what if you need a property that is shared with all instances of a class? That's the purpose of the static modifier.

Static Modifier
The static modifier declares a member that belongs to the class itself instead of to an object of the class. This is useful for tracking information shared between all instances of the class. In this example, we want a count of the number of object instances created from a class. So each instance of the class needs to increment that shared value. Static members are accessed using the class name and not an object variable. Let's try this out. Since we've been working with properties so far, let's use the static keyword on a property. In the customer class, let's add an auto implemented property using a snippet. Remember the shortcut; prop, Tab, Tab. Let's define it as an int, Tab, and call it InstanceCount. We want to share this count with all object instances, so we add the static modifier. Using the static modifier on a class member denotes that the member belongs to the class itself rather than to any specific instance. To see how that works, let's go back to our CustomerTest and add a test for our static property. I'll paste the code, and we can talk through it. In this test, we create three new customers using the new keyword. The object variables c1, c2, and c3 all reference different customers each with a unique FirstName. If we access the object variable c1 and drop down IntelliSense, we see that the InstanceCount property is not there. To access a static property, we use the class name itself. Type Customer., and we now see the InstanceCount property. In this test, we increment this property after each object is created to count the instances. The resulting value should be 3. Open the Test Explorer, pin it, and run this test. It passes. Use the static modifier to declare members that belong to the class itself and not to an instance of that class. We'll see more of the static modifier later in this course. Now let's finish off this module with some checklists we can use as we implement classes in C#.

Checklists and Summary
Checklists are a great way to recheck our understanding and our code. Most applications today are divided into at least three layers; user interface for the forms and pages displayed to the user, business logic for the business operations, and data access for retrieving and storing data. Many applications also have a common library for general purpose code that is useful throughout the application. This can include code for logging, sending email, and other tasks common across the entities. The classes we identified are for the business logic, so we created the business logic component. In Visual Studio, we created a solution for the application and a project for the business logic component. Just like an integer is a type and a string is a type, each class defines a type. Give the class a good name, reflecting the entity it represents. By default, new classes added to a project have no access modifier. To access the class from other classes and projects, set the access modifier to public. There are several ways to define a property. Define a property manually by declaring the backing field with a private access modifier, declaring the C# property and adding the getter and setter. Use auto-implemented properties as a shortcut syntax to create and manage the backing field automatically. These are used when the property getter and setter don't need any logic. And use Visual Studio snippets to make it quick and easy to add properties to any class. Test your classes as you go with unit tests. Create a separate project for the tests, and then set a reference to the business layer component. Define tests for valid and invalid scenarios. Organize each test using an Arrange, Act, Assert style; Arrange to create an instance of a class and set up test data, Act to access the property or method being tested, and Assert to determine the result of the test. We also covered how to work with objects. To create an object from a class, use the new keyword. Use the var keyword to shorten our declarations. Set and get data using C# properties. We learned that objects are reference types and how to use the static modifier to declare a member that belongs to the class instead of an object instance. At this point, the customer class has a set of properties, but what about the methods? We'll add those in the next module.

Building Entity Classes - Methods
Introduction
For our classes to actually do something, we need methods. Methods are the functions that perform our business operations. Welcome back to Object-Oriented Programming Fundamentals in C#, from Pluralsight. My name is Deborah Kurata, and this module continues the process of building entity classes by creating methods. In the last module, we built the business logic component, created the Customer class, and added properties to that class. We then built a unit test to test the logic for one of the properties, but what about the methods we had defined? In this module, we'll create the methods in the Customer class, including special methods called constructors. We'll then use what we've learned so far in this course to create the Product, Order, and Order Item classes.

Building a Class: Methods
In this demo, we examine how to create methods as we create the methods for the Customer class. We are back in Visual Studio looking at the Customer class. In the last module, we created these properties. Let's add the methods after the properties in the code file to keep our class organized. Methods are created using C# function syntax. Let's create a function for validate. I'll paste the code, and we can talk through it. The function access modifier is public, so any other code in the application can call it such as a user interface. The method returns a true or false value defining whether the data is valid. So the return type of the function is a Boolean. The body of the Validate method validates the property values. Let's say that this specification identified that the last name and email addresses were required, so our object data is not valid unless those two properties have a value. Our Validate method code checks that the two properties are not null, empty, or just whitespace. The result is a Validate method that validates the state of the customer object as part of the specification. We have two more methods defined for the Customer class; Retrieve and Save. Here is some step code for a save and for a retrieve. This retrieve returns one specific customer by ID, but what if we need to display a list of customers? If we have a small number of customers, we may also want the retrieve method that retrieves all of them, or if we have many customers, we may want a retrieve method that retrieves all of them for a specific region or all of them with orders that are pending. For our purposes, we'll just define a second retrieve with no parameter that returns all of the customers. This retrieve returns a list of customers as a generic collection. If you are not familiar with the generic list collection, check out the C# Best Practices: Collections and Generics course in the Pluralsight library. We're not going to concern ourselves with the remainder of the code for the Retrieve and Save methods at this time, but we do have completed code in our Validate method. How do we try it out? Another unit test.

Testing the Methods
In this demo, we examine how to test class methods with unit tests. We saw earlier in this course how to test class properties with unit tests. We follow the same process for our class methods. For each method, we write unit tests for both valid and invalid scenarios. Let's build some tests for our Validate method. We'll start with valid values to confirm that the Validate method is performing correctly when the customer data is valid. I'll paste the code, and we can walk through it. We are testing a valid scenario, so we name the test with a method name and valid. We then follow our standard structure; Arrange, Act, Assert. We arrange the test by creating a new instance of the class and setting the properties to test data. We also define our expected result. We expect that the method will return true since we are providing valid data. We act by calling the Validate method, and we assert that the expected and actual values are equal. Build similar tests for invalid scenarios. We'll create a test with a missing LastName. This test ensures that given an email address, but no name, the method returns false because the last name is not provided. Let's open the Test Explorer, pin it, and run these tests. And they both pass. Yay. As you write your code, consider immediately writing the test for that code, or you can use a test first approach whereby you write the test, then write code to pass that test. Either way, it's very beneficial to have unit tests to test the logic of your application. They can catch most bugs in your code right after you've written it while you still remember the details of the requirements. And if you later change any code, you can rerun the test to ensure that any future changes or enhancements don't break your existing code. Now that our Validate method is working, it's a good time to cover a few more method terms.

Terms
When working with class methods, there are a few specialized terms to know. Let's discuss these terms in the context of our code. You may hear the term method signature or function signature. The signature of a method is comprised of its name and the type of each of its formal parameters. The signature does not include the return type. The system uses the signature to match up the calls to that function. So c1.Retrieve is matched to the Retrieve with no parameters. And c2.Retrieve (7) is matched to the Retrieve with a single integer parameter. Each method's signature in a class must be unique, but since the signature includes both the name and the parameters, we can have multiple methods with the same name if the parameter lists differ. That takes us right to the next term, overloading. The term overloading is used to describe methods that have the same name, but different parameters. In this example, the first Retrieve method takes one integer parameter. The second Retrieve method takes no parameters. The Retrieve methods are then overloaded. Since overloaded members have the same name, they should provide variations of the same functionality. In this example, both overloads retrieve customers. If one method retrieved customers and the other retrieved customer types, for example, they should not have the same name because they don't provide similar functionality. The next term is contract. Let's right-click on the class file, and select Outlining, Collapse to Definitions so we can see all of the properties and methods for this class. The properties and methods declared with a public access modifier comprise the class contract. That is to say, the class makes a promise that it will provide the defined properties and methods to any other code in the application that needs them. Over time, the code can extend the contract by adding new properties and methods, but it should not remove properties and methods or modify a method signature once the class has been deployed to production. This contract is also called the class interface. We'll talk a lot more about interfaces later in this course. The Customer class now has properties and methods. Does that mean we are done? Not quite. But before we move on, let's undo our outlining. Right-click on the class file and select Outlining, Toggle All Outlining.

Building a Class: Constructors
In this demo, we look at class constructors. A class constructor is basically a special kind of method named with a class name that is executed each time an instance of the class is created. Constructors are normally defined at the top of the class, above the properties. Use a snippet to create the constructor, ctor, short for constructor, Tab, Tab. The code inside the constructor is used to initialize the object. In many cases in C#, the properties of the object default to valid values, so there is no need to initialize them in this constructor. Because this method is executed when an object of the class is created, it is important that the body of the constructor create the object in a usable state. That is to say there should be no code in the constructor that could generate an error. A constructor with no parameters is referred to as the default constructor. Add additional constructors with parameters as required. If there is no need for code in the constructor, don't create one. An implicit default constructor is defined automatically. Let's create one more constructor. Since the CustomerId has a private setter, the CustomerId cannot be set from outside of the customer class. Let's allow setting of the ID with a constructor. This will be helpful for use in our unit tests. Notice that we now have two constructors with the same name and different parameters, so we have overloaded the constructor. And now that we have an overloaded constructor, we need to define the default constructor as well, otherwise we won't be able to create an instance of an object without the parameter. An implicit default constructor is not automatically created when there are overloaded constructors defined. Now the first cut of our customer class is done. Yay. But what about our other classes?

Building the Remaining Classes
Now that we've covered the basics of creating a class, adding properties to the class, creating methods, and defining constructors, we can repeat that process for the remaining classes. Want to give it a try on your own? If so, stop the video now and build these three classes, skipping the crossed out properties. Ready to see my solution? First, the Product class. It has a default constructor, which is the constructor with no parameters, and an overloaded constructor with a ProductId parameter, similar to the customer class. Here are the auto-implemented properties for the current price; ProductDescription, ProductId, and ProductName. Notice that the current price is defined with decimal?. The question mark denotes a nullable type. A nullable type is a value type such as an integer or a decimal that allows definition of the value or a null. It is useful if the code needs to distinguish between not set and 0. In this case, the price of 0 is a valid price, but it's not valid to have no price. Using a nullable value makes that distinction. The Product class also defines methods, stubs for Retrieve and Save, and the Validate method. Is this similar to what you defined? Let's look next at the Order class. The Order class also has a default constructor and a constructor that passes in the OrderId. The order has two properties; the OrderDate and OrderId. We'll add the customer shipping address and order items later. Notice that we're using DateTimeOffset. The DateTimeOffset value type tracks the date, time, and time zone offset. It's a great type to use when the date can be set in different time zones. For example, someone in Detroit can place an order at 10 A.M., and someone in Paris can place an order at 10 A.M., but those orders were not actually placed at the same time. By keeping the time zone offset, we can correctly compare dates from different time zones. The question mark, again, denotes a nullable type, meaning it can hold the value of the DateTimeOffset or a null. This is especially useful for date types as there is no good default value. The order also has similar methods; Retrieve, Save, and Validate. Lastly, the OrderItem class. Like the other classes, it has a default constructor and a constructor that takes the OrderItemId. It has a set of properties; OrderItemID, ProductId, PurchasePrice, and Quantity. Notice, again, that the PurchasePrice uses a nullable of decimal. The OrderItem class also has the same standard Retrieve, Save, and Validate methods. We have now created all of the classes, but are they the right classes? Are these classes taking on too much responsibility? We'll answer these questions in the next module. Let's finish off this module with some checklists we can use as we implement methods in C#.

Checklists and Summary
When creating class methods, set the appropriate access modifier. To access the method from other classes and projects, set the access modifier to public. Specify the desired return type. This is the type returned from the method. Use void if there is no return type, and be sure to give the method a good name. As methods are actions, method names are often verbs such as Validate, Retrieve, and Save. Test your methods with unit tests when unit testing methods define tests for valid and invalid scenarios, and be sure to organize each test. Arrange to create an instance of the class and set up test data. Act to call the method being tested, and Assert to determine the result of the test. Methods have some unique terminology. A method's signature is its name and set of parameters. The signature does not include the return type. The system uses the signature to match the method call to the appropriate method. Overloading describes methods that have the same name, but different signatures. In this example, the first Retrieve method takes one integer parameter, and the second takes no parameters. The Retrieve method is then overloaded. Since overloaded members have the same name, they should provide variations of the same functionality. All properties and methods defined using the public access modifier define the class contract. That is to say the class makes a promise that it will provide the defined properties and methods to any other code in the application that needs them. A constructor is a special method that is executed each time an instance of the class is created. The constructor name is the name of the class. Constructors can be overloaded as shown here. The default constructor has no parameters, and the second constructor has an ID parameter. In these last two modules, we walked through building and testing an initial version of our customer class and looked at the code for the start of the remaining entity classes. Now let's move on to the second step of building an object-oriented application; separating responsibilities.

Separation of Responsibilities
Introduction
Our Customer class creates new customers and validates customer data. It has methods to retrieve existing customer data and save changes, and we have not even considered how to manage addresses. Sounds like the Customer class is trying to do too much. Welcome back to Object- Oriented Programming Fundamentals in C#, from Pluralsight. My name is Deborah Kurata, and this module details how to keep our classes focused by separating responsibilities to other classes. When a business is small, it's easy for the president of the company to be responsible for everything; sales, marketing, operations, and so on. As the company grows, getting more customers and more employees, this is no longer practical. The president needs to delegate some responsibilities to others. The same is true as we build our applications. When a class has few responsibilities, it's easy for that class to contain all of the code to handle those responsibilities. As an application grows, the class can take on more responsibilities than it can manage by itself. In this module, we think through the responsibilities of our classes and make them more focused by delegating appropriate responsibilities to other classes.

Separation of Concerns
So far in this course, we identified an initial set of classes and their members based on the requirements. The second key step in building an object- oriented application is to look at each of the resulting classes and determine whether it is focused or taking on too much responsibility. Does the class need to do everything specified for it or should it be broken into additional classes? This step follows the principle of separation of concerns. The idea is that an application should be decomposed into parts with minimal overlap and each part responsible for a separate concern. Separating responsibilities minimizes coupling, maximizes cohesion, simplifies maintenance, and improves testability, and who wouldn't want that? Let's look at each of these factors in detail. Coupling is the degree to which classes are dependent on other classes or external resources. The fewer dependencies the class has, the easier it is to write, test, maintain, and update over time. If there are too many dependencies in a class, consider moving some of those dependencies to another class. For example, each of these classes has code to retrieve and save data using the data access layer, making them tightly coupled to that layer. We can reduce that coupling by extracting the retrieve and save operations into separate classes. Cohesion is a measure of how related everything in a class is to the purpose of the class. If there are properties or methods in a class that are not truly related to the purpose of the class, they should be moved to another class. For example, there is a lot of work required to manage an address. There are quite a few properties, and there are requirements such as appropriate address formatting based on the country. Does it really make sense for the customer to manage all of this and the order as well? By moving address functionality into its own class, we maximize cohesion in each class. Why bother concerning ourselves with coupling and cohesion? When there is low coupling, there is a reduced probability that changes to one class adversely affects other classes, making maintenance easier. And low coupling makes testing more straightforward because the class has minimal dependencies on other classes. When there is high cohesion, there is a higher probability that a feature request will affect only a small number of classes, simplifying maintenance. And high cohesion helps produce a focused, well-defined, and complete class, making it easier to understand and test. Classes with both low coupling and high cohesion are easier to understand, test, maintain, and extend. Let's take another look at our entity classes and see if they have any responsibilities that can be best be delegated to other classes.

Revisiting the Class Diagram
Let's start with the Customer class. Yes, the Customer class needs to track the customer's name. Email address? Maybe. If the application allowed tracking of multiple email addresses for a customer, then maybe not. To make our decision, we go back to the subject matter experts and ask about the email address. The answer is that they currently only want to track one email address. They may change their minds about this sometime in the future. Okay, but should we deal with multiple email addresses now, just in case? Following the YAGNI principle, which stands for, you aren't going to need it, don't put in any feature that may be needed in the future. So we'll leave it as a single email address property in the Customer class. How about the home and work addresses. An address requires quite a few properties; multiple lines for a street address, city, state, province, zip code, or other postal code, country, and an address type to identify whether an address is for home or work or whatever. Plus, there are specific business rules and different address formats for different countries. This sounds like something that has enough functionality to stand on its own. Let's define an Address class to take on those responsibilities. Notice that we still have the address fields in the Customer class, but now they are simple instances of our new Address class. Now how about the methods in our Customer class? Validate? Yeah, that makes sense. The Customer class should be responsible for validating its own data. Retrieve? Hmmm, depending on the data access technology you are using; Entity Framework, ADO.NET, or some other third-party framework, the code in the retrieve could be extensive and complex. It doesn't make sense for the Customer class to take on the responsibility of retrieving the data from the data store. Save, same thing. Since both the retrieve and save are dealing with the data store, it would make sense to put both of those responsibilities together in a separate class. By convention, the class responsible for retrieving and saving the data for an entity is called a Repository class. The customer repository includes methods such as Retrieve and Save. A side note here. As we just discussed, a common practice when separating responsibilities is to put code dealing with a data store into its own class. There are many other common practices for defining an appropriate set of classes and their associated relationships. These common practices are called design patterns. There is a design pattern called the repository pattern, which we are using in a simplified form here. Now let's look at the Product and Order classes. It makes sense to use the repository pattern for them as well. Each Repository class includes methods such as the Retrieve and Save, but what about Order Item? We'll talk about that class in the next module. For now, let's build these new classes.

Building the Address Class
In this demo, we build the Address class. If you want to try building this class yourself, stop the video now. Are you ready to see my solution? We are back in Visual Studio with our ACM solution open. Here is the Address class that I created. It has two constructors similar to the Customer class. I created the address properties quickly using the prop snippet for defining auto- implemented properties. And here is our Validate method. For our purposes, only the postal code is required. That's good enough for now. Let's move on to the repositories.

Building a Repository Class
A Repository class handles the interaction with the data store. In this demo, we build the Customer Repository. Let's add the Customer Repository class to our ACM.BL project. Right-click on the project, and select Add, Class. Name it CustomerRepository, and be sure to set the class access modifier to public. I'll paste the code for the body of the class, and we can talk through it. Code in the Retrieve method accesses the data store and retrieves a single customer by ID. Since we want to stay focused on object-oriented programming, not on data access techniques, I skipped the actual data access code and instead added temporary code to the Retrieve, so it will return a populated customer instance. The Save method accesses the data store to save user changes. For now, it simply returns true assuming that the save process was successful. That gives us a start for some repository code. Now let's go to the Customer class and delete the Retrieve and Save methods that were there. What do we want to do next? If you said test our repository code, you've got the right idea.

Testing a Repository Class
In this demo, we build a unit test for our Customer Repository class. Our test folder only contains a class for the customer tests. We want a separate class for testing the customer repository. Right-click on the test project, and select Add, Unit Test. Change the file name to CustomerRepositoryTest, and select to automatically change the class name. Let's change the test method name to RetrieveValid, and follow our standard layout; Arrange, Act, Assert. First, we arrange. Create an instance of the repository and use the quick action to insert the using. Then, define the expected values. We'll use the object initializer syntax we discussed earlier in this course. Recall from the Customer Repository class that we expect a customerId of 1, and here are the values we set in the Retrieve method for the remaining properties. Hmmm, what's wrong with this code? Well, we can't set the customerId because the customerId property setter is private. How are we going to test this? Luckily, we created a constructor that takes the customerId property as a parameter. So we can use that here instead. Remove the Id property, and pass the Id in to the constructor. Next, we act by calling the method we are testing. Lastly, we assert to determine the result of the test. Our first thought may be something like this, but when comparing objects, what does equality actually mean? Unless we specified otherwise, two objects will only be equal if they reference the same object. Let's open Test Explorer, pin it, and run the test. As expected, it fails because, in this case, we have two different objects. The one created with the new keyword here and one returned from the Retrieve method here. So even if they have the same property values, they are not the same object, and are, therefore, not equal. How do we then compare these objects? One way is to compare each property. Rerun the test, and now the test passes. If desired, you can build additional tests for invalid values such as attempting to request a customer that's not there. Now what about the repositories for the other classes?

Building the Remaining Repositories
In this demo, we build the remaining Repository classes for Product and Order, along with their unit tests. If you want to try building these classes yourself, stop the video now. Are you ready to see my solution? The code in the ProductRepository class is similar to the CustomerRepository class. Code in the Retrieve method would access a data store and retrieve a single product by ID. I instead added temporary code to return a populated product instance. Your hard coded data may look different than that shown here. The Save method would access a data store to save user changes. For now, it simply returns true denoting that the save process was successful. Now let's go to the Product class and delete its Retrieve and Save methods. The ProductRepository unit test looks like this. Make sure your expected product matches your hard coded product data. Looking at the OrderRepository, similar to the other repositories, I once again temporarily hard coded values so our retrieve will return data. Notice how I'm setting the date. I'm using the current year and a specific date and time zone. The Save method would access a data store to save user changes. For now, again, it simply returns true denoting that the save process was successful. And let's not forget to go to the Order class and delete the Retrieve and Save methods that are there. The OrderRepository unit test looks like this. Again, be sure your expected order matches your hard coded order data. Let's try out our unit tests, and they all pass. We have now successfully separated the responsibilities in our entity classes to minimize coupling and maximize cohesion, leaving us with more focused classes. All the logic to manage addresses is in a separate Address class, and code that accesses the data store is in Repository classes. Let's finish this module with some checklists we can use as we evaluate our classes and separate out responsibilities.

Checklists and Summary
After using the requirements to define an initial set of classes, evaluate them for coupling and cohesion. Recall that coupling is the degree to which classes are dependent upon other classes or external resources. To reduce coupling, extract dependencies into their own classes. Minimizing coupling makes an application easier to test and maintain because the dependencies are encapsulated. For example, each of our entity classes had Retrieve and Save methods that would access a data store. Decouple the main entity classes from the data store by adding a repository class to encapsulate the data access logic. Cohesion is a measure of how related the members of a class are to the purpose of the class. To increase cohesion, extract unrelated members into their own classes. Maximizing cohesion makes an application easier to understand, test, and maintain because each class is more focused on a single purpose. For example, there are quite a few properties and business rules for managing an address. Improve cohesion by moving the responsibility for managing address into a separate class. We've covered a few additional concepts. The principle of separation of concerns is the idea that an application is decomposed into classes with minimal overlap. Each class is responsible for a separate concern. Our Customer class is now concerned only with managing a customer. The Address class is concerned with managing addresses, and the Customer Repository class is concerned with getting data into and out of the data store. YAGNI is the acronym for you aren't going to need it. It is a principle that focuses on what is important for today. How many times have you built in some hook or designed in a feature that was never actually implemented or later implemented entirely different? We can't see what the future will bring, so it is best to focus on what is needed for today. You can think of design patterns as common practices or best practices for defining appropriate sets of classes and their relationships. If you are interested in learning more about design patterns, there are courses in the Pluralsight library on that topic. The Design Patterns On-Ramp course is a great place to start. In this module, we evaluated each class for coupling and cohesion to determine whether the class had too many responsibilities. Let's proceed to the third step of building an object-oriented application; establishing the relationships between the classes.

Establishing Relationships
Introduction
Our classes need to relate to each other so they can interact. Welcome back to Object- Oriented Programming Fundamentals in C#, from Pluralsight. My name is Deborah Kurata, and this module walks through how to define the relationships between classes and implement those relationships in code. Looking at the list of tasks for building an object-oriented application, we've identified the first cut of our classes with their properties and methods. We analyzed the responsibilities of those classes and moved some of those responsibilities to other classes to minimize coupling and maximize cohesion. The third key step is to look at the relationships between those classes. The relationships define how the objects interact and work together to perform the operations of the application. To interact and communicate, there must be a relationship between the objects. Take, for example, a feature to display an order. Here is a user interface component with a form to display an order summary. Here is the business logic component with Order Repository, Order, and Order Item classes. As its name suggests, the order summary form displays a summary of an order. To get the data to display, it creates an instance of the Order Repository class and uses the resulting object to call its Retrieve method. The Order Repository Retrieve method retrieves order information from a data store. It creates an order object and uses it to populate the properties of the order with the data retrieved from the data store. The order summary also needs the order item detail. So the Order Repository creates order item objects for each product included in that order and populates the properties of each order item. The Order Repository Retrieve method then returns the fully populated order and order item objects to the user interface. The form uses these objects to display the order and order item data on the form. This example shows how relationships between these classes allow the objects to work together to perform a specific operation. In this module, we begin by defining relationships between our classes. Then we more formally identify the basic types of relationships in object-oriented programming and examine those types in detail, starting with collaboration and composition. We implement composition two different ways using object references and using IDs. Lastly, we examine another type of relationship; inheritance. Let's get started.

Defining the Relationships
These are the classes that we have defined so far. Let's remove the list of properties and methods and rearrange the classes so we can see the relationships more easily, and let's add an address repository to retrieve and save address information. If the Customer class was the only class with an address, we could consider skipping the address repository and instead serializing the address information with the customer information, but since we have an address in both the Customer class and the Order class, we want the address to retrieve and save separately. To define the appropriate relationships, let's start with the Customer class. The customer class has a home address and an office address, so the customer and address are related. Looking at the Order class, the order has a customer, has a shipping address, and it has a set of order items. Each order item must be associated with a product because only products that the company has can be ordered. And looking at the repository classes, the Product Repository populates or saves an instance of the Product class. The Order Repository populates or saves an instance of the Order class, and so on. So these are the many relationships between our classes. But before we implement these relationships, it's important to understand what type of relationships these are.

Types of Relationships
Object-oriented programming defines three basic types of relationships. Collaboration, or uses a, defines a relationship where one object collaborates with, or uses, another object that is not otherwise related. For example, you may collaborate with a coworker to complete a task. In our class diagram, the customer repository uses a customer object to populate on a retrieve. Composition, or has a, defines the relationship where an object is composed of other objects it needs. For example, a car has a motor and has a steering wheel. In our class diagram, an order has a customer, an order has a shipping address, and an order has a set of order items. Without those, it's not much of an order. You may see the has a relationship broken into two distinct categories. Aggregation, when an object is composed of multiple objects that can exist outside of the relationship. For example, an order has a customer, but a customer can't exist without the order. The relationship is simply aggregating, or bringing together, the objects for a purpose. Composition is then limited to those relationships where the related objects don't otherwise exist. The object owns its related objects, and if the object is destroyed, the related objects are also destroyed. For example, an order has a set of order items. The order items have no context without an order. In this course, we'll use the general term of composition to cover both categories. Inheritance, or is a, is the third type of relationship defined in object-oriented programming. We don't yet have an inheritance relationship in our class diagram. Conceptually, we could define a business type of customer is a customer, a residential type of customer is a customer, and so on. As you think about the relationships between your classes, keep in mind that we are not looking at general relationships, but rather relationships with respect to our application requirements. We don't care if a customer has a pet for our particular application, but we do care that the customer has an address. Now let's look at each of these relationships in detail.

Collaboration
A collaboration, or uses a relationship exists whenever an object from one class uses one or more instances of another class it is not otherwise related to. At run time, objects interact by providing services to each other. The entity repository relationships are an example of this type. The customer repository uses a customer object to populate on a retrieve and to serialize on a save. Same for the order, product, and address repositories. Let's see what collaboration looks like in the code. Here we are back in Visual Studio with the ACM solution open. The repository classes we have created are all similar, so let's look at the CustomerRepository as an example. In the Retrieve method, the repository uses an entity class to create a new instance and populate it from information in the data store. At this point, we have simply hard coded values. This allows us to run the code without having the data access layer in place. In the Save, the repository uses a entity class, taking in a customer instance as a parameter. It can then use the information from that instance to save the information to the data store. Recognize a collaborative relationship when you see a class use an instance of an otherwise unrelated class to perform an operation. So that's an example of collaboration. Next, let's look at composition.

Composition
A composition, or has a relationship exists whenever an object from one class is composed of one or more objects from another class. The customer address relationship is an example of this type. The Customer class has a home address and has a work address. The order is also composed of other objects. Each order has a customer, each order has a shipping address, each order has a set of order items, and each order item has a product. How do we implement these relationships? Composite objects often contain references to their constituent objects as properties. The Customer class has home address and work address properties. The Order class has customer, shipping address, and order items properties. The Order Item class has a Product property. Composite relationships also have a cardinality, that is to say they have a one- to-one, one-to-many, or many-to-many relationship. For example, each order has one and only one customer. Each order has one or more order items. Let's see what composition relationships look like in code.

Composition: References
This demo implements a composition relationship, specifically the customer address relationship. We are looking at the Customer class. According to the application specification, each customer has a home address and has an office address. When creating a customer object at run time, the customer object references two address objects; one for the home address and one for the work address. We could add two properties to the Customer class, each of type Address. Alternatively, we could create a list of addresses that more easily allows for any number of related addresses. So that's it. A simple property establishes the composition or has a relationship between the Customer class and Address class. But there is one small issue we should consider when using a list as one of the properties. The list does not have a good default value. Earlier in this course, we talked about constructors. A constructor should ensure that an object is in a valid state when the object is constructed. We didn't initialize our customerId or string values because the system initialized those types to default values for us. But for a list, the default is null. If any code attempts to access the AddressList property, the code will throw a null value exception. To prevent this exception, we'll modify the constructor to create an appropriate instance of the address list. Any other code can then access this property without getting a null value exception. We could add this same line of code to the default constructor, but then we have repeated code. A better technique is to modify the default constructor to call this constructor by inserting a colon and the this keyword. We pass in a 0 since the constructor we are calling requires an ID parameter. This technique is called constructor chaining. Use it any time one constructor needs to call another. In this case, the default constructor calls the parameterized constructor, providing a default customerId value of 0. Now the address list is always initialized regardless of how the customer object is constructed. So we've just seen an example of composition. In composition style relationships, an object from one class is constructed of objects from other classes. In this case, the construction of the customer object constructs a list of addresses objects. At this point, we have an initialized empty list of addresses, but we don't currently have an address repository, so we have no way to populate the address list with data.

Populating the Referenced Objects
In this demo, we walk through how to populate our referenced object, specifically the addresses. The Customer class now establishes the compositional relationship by constructing a set of addresses when the customer object is constructed, but that's not enough. When populating a customer object, where would the data for these addresses come from? If the Address class was only used by the Customer class, the customer repository could take the responsibility of retrieving and saving the address. But since the Address class is used by several classes, we'll build a separate address repository and use it to retrieve the addresses for our customer. I've already created the Address Repository class and added the basic code. As with all of the other repository classes, the Address Repository class has Retrieve and Save methods. The Retrieve method creates a new instance of the Address class and populates it from data retrieved from the data store. We hard coded an address so we can use it for testing purposes. The Save method takes an address object in as a parameter, then returns true to denote that the save operation was successful. The code in between depends on your selected data access strategy. Looking again at this Retrieve method, it retrieves a single address. When retrieving the customer's addresses, it would be better to retrieve all of the customer's addresses at one time, so let's add another method to the address repository. The method is public, so other parts of the application can retrieve addresses. Since there could be multiple addresses for a specified customer, the method returns an IEnumerable of Address. An IEnumerable is the recommended way to return a sequence of data because the results are more flexible for the callers of the method. We'll name the method RetrieveByCustomerId, and pass in the customerId. I'll paste the body of the code. Here we define the list of addresses, and add a few hard coded addresses to the list, so we can run the application without having the data access code in place. Since we want to populate the customer's addresses when we populate the other customer data, we modify the CustomerRepository to use the address repository. In the CustomerRepository, first, create a private property for the address repository. Then build a constructor, and create an instance of the address repository in that constructor. This establishes a collaborative relationship between the CustomerRepository and AddressRepository. Lastly, modify the retrieve to call the new RetrieveByCustomerId method, and populate the address list. Call the ToList method on the returned IEnumerable to return the result as a list. ToList is a link method. Now when any code requests to retrieve a customer, this method will retrieve and populate the customer and its associated addresses. Let's test what we've done so far.

Testing a Composition Relationship
In this demo, we walk through how to test a composition relationship, specifically the relationship between the customer and address. Our CustomerRepository Retrieve method now populates the customer and addresses. To ensure our new code is working, let's add a test to the CustomerRepositoryTest file. Before we begin, a side note. The CustomerRepository Retrieve method now calls the AddressRepository to retrieve the addresses for the customer. This establishes the collaborative relationship between the CustomerRepository and AddressRepository. Writing a unit test for this retrieve means that we are no longer just testing the CustomerRepository, but the AddressRepository as well. Some developers don't allow testing of collaborators in a unit test. Rather, they fake or mock the collaborator to ensure the test is only testing the specific unit of code, but that means that a developer could not write a test for this code until they've learned how to properly write testing fakes and mocks. Pragmatically, it's much more important to have tests, so if our tests use the collaborators, so be it. The tests can be re-factored later as needed or desired. With that said, I'll open the CustomerRepositoryTest file, and paste our new test. We arrange the test by creating a new instance of the CustomerRepository. Then we create a new Customer instance with an ID of 1 and specifying the properties for the expected customer. This code uses a collection initializer to set up the list of addresses. The generic list used here is provided in the System.Collections .Generic library, so use the quick action to add the needed statement. We act by calling the customerRepository.Retrieve method, retrieving the customer with an ID of 1. We assert by checking each of the properties. Recall that we can't simply compare the expected customer instance to the retrieved customer instance because those are only equal if they reference the same customer, not two customer instances with the same property values. Now open the Test Explorer, pin it, and let's run all of the tests. And they all pass. Yay. In this example, we implemented the composition relationship between the customer and address using an AddressList property that references address objects. But there is another way to define a composition relationship.

Composition: Ids
We've implemented the collaborative relationships between the repository and entity objects and defined the composition relationship between the customer and address by implementing a property in the Customer class for the list of addresses. Now when a customer is populated, the customer's list of addresses is also populated. This solution assumes that every time a customer is retrieved, that the addresses are needed as well. Let's implement the composition relationship between the order and the customer and the order and the address using a different technique. When populating the order object, the order doesn't care about the customer details such as home and work addresses. The order has its own address property. So instead of a property that is a reference to the customer, which would then load all of the customer details, let's instead establish the relationship between the order and the customer by adding a property for the customer ID. Same for the shipping address. We'll define a simple integer property for the address ID in the order. There are several advantages to using ID properties instead of object properties to establish a relationship between classes. It reduces coupling because the class no longer has a reference to its related class. In our example, the order class does not need to directly reference the customer or address classes. And it can be more efficient because loading an object does not load the data for its dependencies. In our example, the order repository does not need to load all of the customer information and the shipping address each time it loads the order. Let's see what this looks like in the code. This is the Order class we created earlier in this course. For the relationship between the order and the customer, we'll define an ID. I'll use a snippet, prop, Tab, Tab, int, Tab, CustomerId. And then for the relationship between the order and the address, prop, Tab, Tab, int, tab, ShippingAddressId. That's it. When the order repository populates the order, these ID properties are populated, but not the customer or address details. To finish off the properties for this class, let's define the composition relationship between the order and the order items using references by defining a list of order items; prop, Tab, Tab, ListOrderItem, Tab, OrderItems. Since the generic list is in the Systems.Collections .Generic library, use the quick action to add the using statement. And we'll modify the constructor to initialize the list as we did with the address list. Initialize the OrderItems in the constructor here. Then chain the constructor here. The order now has a customer as defined by this ID, has a shipping address as defined by this ID, and has a set of OrderItems as defined by this list. We have now looked at collaboration and composition relationships. What about inheritance?

Inheritance
We've ignored one of the statements in the original application requirements. The new system must manage business, residential, government, and educator types of customers. We don't currently have anything in our model to handle customer types. There are several ways we can handle these types. One option is to use inheritance. Inheritance provides a mechanism for defining classes that are a more specialized version of another class. For example, we already have a Customer class. We could create additional classes that define more specific types such as a business customer class, residential customer class, and so on. The Customer class in this example is referred to as the parent or base class. Each specialized class is called a child or derived class because it is a derived special case of the class above it in the hierarchy. Each child class inherits, or takes on, the members of its parent class. In our example, the business customer class inherits all of the members of the Customer class, including the customer name, email address, and so on. The specialized business customer class would only need to implement the additional features for the specific type. In this way, the specific classes leverage reuse in that they are using the properties and methods already defined in the parent class. Each class in a lower branch of the hierarchy has an is a relationship to the class above it in the hierarchy. So a business customer is a customer and inherits all of the properties and behaviors defined for the customer, a residential customer is a customer, and so on. If the requirements warranted it, we could expand the hierarchy even further and define local government customers, and state government customers, and so on. When implementing inheritance in C#, a class can only have one parent class. C# does not support multiple inheritance. There can be any number of inheritance levels. From customer, to educator, to high school, to teacher, and so on. Defining subtypes using an inheritance hierarchy can be helpful when first thinking about the classes and their relationships, but they are not always useful when defining the classes to implement. Only build an inheritance relationship between classes if the derived classes have specialized properties or behaviors that require unique code. And you can significantly leverage code reuse from the base class. Let's think about these customers. Will there really be much difference in the code for business verses residential verses government verses educator customers? If not, the easiest way to define the subtypes is with a simple type property. We'll see how to use inheritance to reuse code in a later module. For now, let's add a customer type property to the Customer class to handle the type of customer. Here in the Customer class, let's add a CustomerType property. That should do it. The class now has a property that represents the type of customer. Let's finish this module with some checklists you can use as you define the relationships between the classes and your applications.

Checklists and Summary
A class has a collaboration or uses a relationship when the class uses another class that is otherwise unrelated. For example, the customer repository uses a customer instance to populate data. Implement this relationship by creating an instance of the collaborating class and accessing its properties or calling its methods. A class has a composition, or has a, relationship if the class is made up of, or composed, of parts from other classes. For example, an order isn't an order unless it has a customer, shipping address, and set of order items. There are two ways to implement a composition relationship. Implement composition with a reference property if you want to retain and load the related object, or list of objects, as part of the main object. In this example, the order retains its set of order items. Implement composition using an ID property instead if you want to retain the relationship, but don't always need all of the related object's data. In this example, the order has a CustomerId to establish the relationship between the order and the customer. A class has an inheritance, or is a, relationship when defining classes that are a more specialized version of another class. For example, here we define more specialized versions of the Customer class. This relationship is useful when understanding the business requirements. But only implement this relationship if the specific class type adds unique code. In this example, the derived types did not add any unique code, so we implemented the CustomerType as a simple type property in the Customer class instead of inherited classes. Recall the first two pillars of object- oriented programming we discussed earlier in this course? Abstraction helps us map the business requirements to an initial set of classes. Encapsulation helps keep our properties and method code protected within the class and only accessible through a public programming interface. Inheritance is the third pillar of object- oriented programming. It helps us leverage reuse. Speaking of reuse, now that our classes and their relationships are defined, let's take a focused look at reuse. We'll revisit inheritance and how we can use it and other object-oriented programming techniques to reuse code.

Leveraging Reuse through Inheritance
Introduction
It is said that the power of object- oriented programming is in its promise of reuse. Welcome back to Object-Oriented Programming Fundamentals in C#, from Pluralsight. My name is Deborah Kurata, and this module demonstrates how to leverage reuse through inheritance. We've already identified the first cut of our classes with their properties and methods using the words from the requirements. We analyzed the responsibilities of those classes and moved some of those responsibilities to other classes. This keeps each class focused on its purpose. We then identified and implemented the relationships between those classes. The relationships define how the objects interact and work together to perform the operations of the application. The fourth key task when building an object-oriented application is to leverage reuse. For existing code, this involves locating similar functionality and extracting that commonality into reusable classes or components. This task can also involve some precognition, identifying potential commonality and building reusable common classes and components, and interfaces. We can use object-oriented programming techniques to leverage reuse, build a class with common functionality, and share it through collaboration or composition. We saw this in action with the Address class. Any class can reuse the Address class to manage address functionality, extract common code into a base class, and inherit from that class. Each child class reuses the properties and behaviors of the base class. Build fully encapsulated components. For example, we could build a library of common utilities and reuse them in any application. Define interfaces to work with a set of classes in a common, reusable way. And copy and paste. Yeah, we could copy some code and paste it to reuse it. This is often jokingly called cut and paste inheritance. But by making a copy of the code, there are then two or more places that the code resides. When a bug is found in one copy, someone needs to remember to update every other copy. This takes time and is prone to error, so it's not a great idea. We looked at collaboration and composition earlier in this course. We build a reusable component and examine interfaces later in this course. The remainder of this module focuses on inheritance. We begin with a look at the .NET Object class as an example of leveraging reuse through inheritance. Sometimes you want different functionality than a base class provides. In that case, you can override the default base class functionality and provide a more specific implementation. We'll dive into this concept and look at an example. We then cover polymorphism, which is the fourth and final pillar of object-oriented programming. Lastly, we build our own base class with common functionality for all the entity classes and demonstrate how to inherit from this base class. Before we get started, let's look at the secrets of reuse.

Secrets of Reuse
Psst, come here once. Let me tell you the secrets of reuse success. Build a functionality once. Test that functionality with unit tests. Be sure to retain the tests for regression testing. Of course, the most important part, actually reuse the resulting class, component or interface. This may require some processes to ensure all team members know what is available for reuse. And if you need to later update, extend, or enhance that functionality, you only have to enhance it in one place. When a bug is found or a change is required, update that functionality once and retest it. All the code that reuses the shared functionality will immediately have the fix or support the new feature. Reusing existing classes, components, and interfaces has many advantages. It reduces the amount of code you need to write, which reduces the development and maintenance time and associated costs. Plus, it reduces bugs because the reused piece can be tested independently. Now let's get started with a look at techniques for leveraging reuse through inheritance.

The .NET Object Class
We've been talking about inheritance for a while now. We talked about how we could define an inheritance relationship for our customer types, but since we didn't need any specific properties or behavior in our derived classes, we opted to implement our customer type as a simple integer property. So you may have been wondering when you would see inheritance implemented, but actually you've already been using inheritance in the demonstrations so far. How, you ask? .NET has a class called object. This name is a bit confusing because the object class is not an object, it's a class named Object. Every class we create, and I mean every class we create, inherits from this Object class. Since every class inherits from this Object class, all the members defined in the Object class are available and reusable from the derived classes. Let's take a look. We are back in Visual Studio with the ProductRepository class open. Let's try a few things here. Since the built-in .NET object is a class, we can create an instance of it; Object myObject = new Object. If we type myObject., we see the list of methods available on the object class. The ToString method returns a string representing the current instance of the class. The default implementation of the ToString method in the Object class returns the fully qualified name of the type. Let's write it out to the console using an interpolated string. Since every class we create automatically inherits from object, every object from each of our classes has a ToString method. Looking at the Product class, we didn't create a ToString method. But going back to the repository, if we type product., we see that our product instance does have a ToString method that it inherits from the .NET Object class. Let's write that out to the console as well. Note that we did not have to define this inheritance relationship. When we create a class, .NET automatically inherits from the .NET Object class. We don't currently have a user interface to run this code, so we'll run it by executing the unit test. Open the Test Explorer, and pin it. Select to run the ProductRepository RetrieveTest. In the bottom portion of Test Explorer, click the Output link, and we see that the ToString method displays the full class name of the .NET Object class and the full class name of our Product class. Going back to the ProductRepository class, Visual Studio itself makes use of this inheritance relationship when displaying information while debugging. It uses the ToString method from the object class to display the fully qualified type name for any object variable in the tooltips. To see what I mean, let's put a breakpoint in after we create the instance of our product so we can view the product object. In Test Explorer, right-click and select to debug the test so it'll stop on the breakpoint. Hover over the product instance variable. Notice the tooltip provides a string description of the class. Internally, Visual Studio is calling the ToString method. Since every class we create implicitly inherits from the Object class, Visual Studio can reuse the inherited properties and methods with any instance of any class. That makes features such as displaying the data tooltip possible. Click the red square to stop the test. The key point when leveraging reuse with inheritance is that every derived class has access to the properties and methods of the class it inherits from. Code in the base class is available for use by the derived classes, so we can call the Object class ToString method from the Product class, or from the Customer class, or from any class. But what if we want to change the functionality of one of the base class methods for a specific derived class?

Overriding Base Class Functionality
In this demo, we override base class functionality for a specific derived class to provide a more specialized implementation. Recall that the ToString method in the object class displays the name of the class type. For the Object class, it displays System.Object. For our Product class, it displays ACM.BL .Product. It would be much more useful if the ToString method provided a string more specific to the derived class, especially when used with debugging. For example, it would be great if the Customer class could write its own implementation of the ToString method that displayed the customer name. And the product class could have its own implementation of ToString that displayed the product name. That way we could better see which object we are working with. Luckily for us, we can do just that. We can override the base class member in our derived classes. Let's override the ToString method in the Product class. With Visual Studio, it's easy to override any inherited member. Just type override, space, and IntelliSense provides the list of members available to override. The list includes any overridable members in any class above it in the hierarchy. Our Product class inherits from object, so we see the object class's overridable members in the list. We'll pick ToString. Note that not all members of a class are overridable. We'll talk more about that later in this module. Visual Studio automatically creates a set of default code. This default code simply calls the ToString method in the base class. We want to display information about the current instance, so let's return the ProductName instead. Notice that the quick action is offering a suggestion. Since this method is a single line, we can shorten this syntax using expression bodied members. Expression bodied members leverage lambda expressions instead of statement blocks to shorten the syntax. Now let's rerun the unit test and view the data tooltip. Right-click on the ProductRepository RetrieveTest, and select Debug Selected Tests. The debugger will stop at the breakpoint we set in the last clip. Hover over the product object, and we see the product name. Wow. That is much more helpful than just seeing ACM.BL .Product. It is now providing information on which product this object variable represents. Click to stop the test. To make debugging easier, consider overriding the ToString method in every entity class. We can then more easily see information about each instance from that class while debugging. Open the Customer class and add the override, returning the full name. And in the Order class, returning the order date and ID. We can also use the ToString method in our code for logging information about a specific instance. Now is a good time to introduce another term; polymorphism.

Polymorphism
Polymorphism is an impressive sounding word that basically means many shaped. In object-oriented programming, polymorphism is the concept that a single method, such as the ToString method, can behave differently depending on the type of object that calls it. If the base class calls ToString, ToString displays the full class name. If an order object calls ToString, it displays the order date and ID. If a customer object calls ToString, it displays the customer's full name, and if a product object calls ToString, it displays the product name. So a method can have different shapes. The application determines which shape of the method to use at the time of execution based on the type of instance that called it. This demonstrates inheritance-based polymorphism, whereby a base class defines a method, and any derived class can override that method to provide its own implementation, basically providing its own shape for the method. Polymorphism allows us to work with groups of classes in a uniform way. We saw this when we looked at the data tooltips. Visual Studio leverages polymorphism to display the appropriate information in the data tip based on the type of object. Now that we have covered how to use a base class and override its methods, let's see how to create a base class of our own.

Building a Base Class
So far, the demonstrations have pretty much ignored the save functionality. Why? Because there's all sorts of fiddliness involved when we have to actually save data. Is it a new item? Then there may be specialized operations to perform. To track if the item is new, each entity class needs an IsNew property. Is the data actually changed? If we display data to a user, they may look at it and not actually change anything, so we don't need to save it. To track whether the user has made changes, each entity class needs a HasChanges property. Is the data valid? To track that, each entity class needs an IsValid property that calls its Validate method to determine if the data is valid. What if the user deleted the item? It is normally good practice not to actually delete any data, especially if that data is related to other data in the application. For example, an order is associated with a customer. If the customer is deleted, the order can't be displayed. Instead, add an EntityState property to track whether an item is active or deleted. So every entity needs another property; EntityState. Do we want to add each of these properties to every entity class? I don't think so. Let's instead define a base class that has these properties. Every entity class can then inherit from this base class to access all these new properties. When building a base class, we have two choices. We can build an abstract class or a concrete class. An abstract class is an incomplete class with at least one property or method that has not been implemented. Because an abstract class is incomplete, it can't be instantiated. That means we can't use the new keyword to create one. An abstract class is intended for use as a base class, and not used on its own. Define an abstract class using the abstract keyword. A concrete class is a normal class like we've been creating so far in this course. A concrete class can be instantiated. That means we can use the new keyword to create one. A concrete class can be used as a base class or on its own. When creating a class, a concrete class is created by default. No additional keyword is required. Our new EntityBase class is only meant to be used as a base class, so we'll build it as an abstract class. There is one more concept to cover before we dive into building our base class, and that is a sealed class. A sealed class is a class that cannot be extended through inheritance. Sealing a class prevents extension and customization. If you build a class and want to ensure that no other classes extend or override its functionality, consider marking it as sealed. Seal a class using the sealed keyword. Since we are building a base class, we want it to be extended and not sealed. But if we don't want any other code to extend our entity classes such as our customer or product classes, we could seal them. Now, let's build our base class.

Demo: Building a Base Class
In this demo, we'll build the base class for our entity classes. In it, we'll declare the properties each entity class needs to perform the save operation. Create a base class like any other class. Right-click on the ACM.BL project, and select Add, Class. Name the class EntityBase. Ensure the class is public, and let's mark it as abstract so it can only be used as a base class. Now we are ready to add our new properties using the property snippet. The IsNew property defines whether the object represents a new entity such as a new customer. For the IsNew, use propg to define a property with a getter and private setter. We don't want any other code defining whether the entity is new. It's a Boolean, and we'll call it IsNew. What is the appropriate access modifier for this property? Use public if any class can access the property. Use private if only the base class can access this property. Use protected if the base class and all derived classes can access this property. We could make it protected so only the entity classes could access it, but we may want to also access it from the associative repository classes, so let's leave it public. The HasChanges property defines whether the entity has been changed. I'll place the properties in alphabetical order. Use prop to create the property. It's also a Boolean. We'll name it HasChanges, and we'll leave it public as well. IsValid defines whether the entity's data is currently valid. It's a read-only property, and we'll call the entity's Validate method to determine if the class data is valid. I'll paste the code. Each of our entity classes has a Validate method. So can we just call their Validate method here? Hmmm, no. The base class does not know about the properties and methods defined in the child classes. We'll deal with that later. Let's just return true for now. Lastly, EntityState defines whether the item is active or deleted. For this property, we'll define an enum for the valid values; active and deleted. Then use prop, set the type to that enum type, EntityStateOption, and call it EntityState. That's it. Now that we have the base class in place, we can inherit from it. We want each of our entity classes to inherit from our EntityBase class. Let's start with the Product class. To inherit from a base class, add a colon after the class name and specify the name of the base class. In our case, it's EntityBase. That's it. That's all we have to do to inherit from a base class. Let's try it out. Ensure that our breakpoint is still defined in the ProductRepository class. Then debug the ProductRepository RetrieveTest. Hover over the product, open the data tip, and we see that the product instance has all the base class properties. Cool. Let's stop the debugger. Looking back at the EntityBase class, let's revisit the IsValid property. We want this property to call the Validate method of the appropriate entity object. The IsValid property can't call our derived class validate methods, but it can call a local validate method. Let's add one here. Now we can call this method in our Validate getter. We are getting a quick action suggestion to convert this one-line getter to an expression body property. Let's take that suggestion and shorten our syntax. We'll ignore this error for now. The last step then is to simply override this Validate method in every entity class that inherits from this class. The IsValid property here in our base class makes use of polymorphism to call the correct shape of the validate method, calling the appropriate Validate function based on the entity type. In the Product class, let's add the override keyword to our Validate method. But it doesn't work. We see an error; can't override inherited member because it is not marked virtual, abstract, or override. Now what?

Preparing Overridable Base Class Members
By default, class members are sealed and cannot be overridden. That was the cause of our error. Expose members using abstract or virtual. When do we use which? Abstract methods are just a placeholder with no implementation. Use abstract if the base class defines the method, but has no default code for the method. But note that we can only add abstract methods to an abstract class because defining an abstract method leaves our class incomplete. The derived class must then override each abstract method. Specify an abstract method using the abstract keyword. Virtual methods have a default implementation that can optionally be overridden. We can add virtual methods to abstract or concrete classes. Use virtual if it makes sense to have default code in the method. The derived class then has the option to override any virtual method. Specify a virtual method using the virtual keyword. Recall that earlier in this module, we overrode the ToString method. The ToString method is a virtual method. It had a default implementation it used if we didn't override it. Our EntityBase class has no default validation logic. Only the entity classes have a logic to determine if their data is valid. So we'll use abstract for our base class Validate method. Let's give it a try. To prepare our base class member so it can be overridden, let's add the abstract keyword. An abstract method has no implementation, so we don't need a method body, and instead, add a semicolon. Going back to the Product class, we see that our Validate method is valid, no syntax error. Our overridden method is called whenever the IsValid property is accessed on an instance of the Product class. Now that we have our EntityBase properties in place, it's time to use their functionality. We'll use the EntityBase properties in our repository class Save method, starting with the ProductRepository. I'll paste the code, and we can talk through it. We first declare a variable defining whether the operation was successful, and set it to true. We check whether the product has changes. If it has no changes, we don't need to save. Then we check if it's valid. The IsValid will call our overridden Validate method. If the product has changed and is valid, we check the IsNew property to call either an insert or update operation. If the product is not valid, we return false. Let's test our Save method. In the ProductRepositoryTest class, I'll paste a test for a valid and invalid scenario. For the valid scenario, we arrange the test by creating an instance of the ProductRepository, and define an updated product. We act by calling the Save method, and then confirm that the save was successful. Since we aren't yet actually saving anything, success is simply that the data was valid. For our invalid test, we arrange the test by creating an instance of the ProductRepository, but this time, our updated product has a null current price, which our validation should catch as invalid. We again act by calling the Save, and confirm that the save was not successful. Open Test Explorer, pin it, and run the ProductRepositoryTests. They pass. We now have a base class that all of the entity classes can use. Feel free to inherit from it in each of the remaining entity classes, and repeat the Save code in each of the repository classes. Let's finish this module with some checklists for leveraging reuse through inheritance.

Checklists and Summary
One of the driving forces behind object- oriented programming is reuse. This module focused on leveraging reuse through inheritance. With inheritance, we can define a base class with common functionality and inherit from that class to reuse that functionality. An abstract class is an incomplete class with one or more members that are not implemented. Because an abstract class is incomplete, it can't be instantiated, meaning we can't use the new keyword to create an instance. Use abstract when creating a base class. Each derived class then implements the members that are not implemented in the base class. Use the abstract keyword to define a class as an abstract class. A sealed class is a concrete class that can't be extended through inheritance. Use the sealed keyword to prevent overriding the class functionality. Before a base class method can be overridden, that method must be defined as abstract or virtual. An abstract method is a placeholder with no implementation. Use it if the base class does not have a default implementation for the method such as in our validate example. The method must then be overridden in the derived class. Abstract methods can only be used in an abstract class. A virtual method has a default implementation and can be used in an abstract or a concrete class. The method can be overridden in the derived class if needed. Here again are the pillars of object-oriented programming. Abstraction helps us map the business requirements to an initial set of classes. Encapsulation helps keep our properties and method code protected within the class and only accessible through a public programming interface. Inheritance helps us reuse code by inheriting properties and methods from a base class. Polymorphism is the fourth and final key characteristic of object- oriented programming. It allows us to write a method with many shapes. A single method such as ToString or Validate can behave differently depending on the type of object that calls it. That gives us the ability to override base class methods in the derived class to provide more unique functionality. In this module, we covered reusable classes. Now let's build a reusable component.

Building Reusable Components
Introduction
As we build our applications, we often find ourselves writing general purpose code that is not specifically business logic, code like string handling or logging. Welcome back to Object-Oriented Programming Fundamentals in C#, from Pluralsight. My name is Deborah Kurata, and this module continues the discussion on leveraging reuse by building a reusable component. C# applications are developed by building one or more components and using object- oriented programming techniques to define and build the classes within each component. In this diagram, we defined four components. Two components in the user interface layer, one for the desktop application using WPF, and one for a web front end. There could be more user interface components for other technologies. The business layer has one component, which we have been building throughout this course. We are only showing three of the classes within this component to keep the diagram manageable. But this layer can include many more classes and additional components. There is also a component in the data access layer that handles calls to the database through ADO.NET, Entity Framework, or some other data access technology. The repository classes call this component to access the database. Each component is created within Visual Studio by adding a new, separate project. So far, we created one project; ACM.BL, so we have one component. And we created a project for the unit test that is not shown in this diagram. Each component can be separately compiled and deployed. Are these components reusable? In this diagram, the business layer component is reused by the WPF and web user interface components. Both use the logic included in the business logic layer. And if we build generalized data access code, we may be able to reuse the data access layer component over multiple projects. As we develop these components, we may find ourselves writing general purpose code that does not belong to any layer such as code to perform string operations, code to perform logging, code to email notifications or receipts, and so on. Let's build a new component to define a reusable library of general purpose classes. The result can be used in any application. In this module, we build a reusable component and build a unit test to test that component. We then walk through how to use that component from our business logic component. Static classes are often used in these types of reusable components, so we look at what static classes are and when and why you would use one. And lastly, we examine how to add reusable methods to existing classes, including .NET classes using extension methods. Let's get started.

Scenario
We again meet with the subject matter experts and they bring an issue to our attention. Much of the product data for our ACM application is coming from another system. That third-party system is storing product names without spaces. When our application retrieves that data, instead of Sonic Screwdriver, two words, it is provided as SonicScrewdriver with no spaces. The customer is often confused by this when using our system. Can we reinsert the needed spaces before displaying the name? The code can assume that a space should be inserted before each uppercase letter. We say no problem, and get to work. We are back in Visual Studio with the Product class open. Since the product data store contains the product name without spaces, we want to add code to the product name getter to insert the appropriate spaces. The ProductName property is currently an auto-implemented property, so we can't add code to the getter or setter. Our first step then is to convert the auto- implemented property into a fully-defined property. I'll paste the code. Now we want to add code in the getter to insert spaces into the ProductName. Let's think about that a moment. Do we really want to write all that code here in the getter? Wouldn't it be better as a separate method? That will make it easier to build and test. Let's write the method down here. The method needs to return a string, and we'll call it InsertSpaces. In the body of the method, we could use the ProductName field as the source string to start with, but this will be easier to test if we pass the source string in as a parameter. We have just defined a signature for a general purpose method that takes in any string and inserts spaces. Does that method belong here? Should the Product class have responsibility for converting strings? And what if we want to use this method from other classes? When you find yourself creating general purpose methods such as this, consider putting them in a general purpose class. And if the resulting class is reusable throughout the current application and possibly other applications, consider creating a reusable library of general purpose classes. Code libraries are a convenient way to package and reuse a set of classes. Let's delete this method from our product class and build a code library for it instead.

Building a Reusable Component
In this demo, we build the start of a general purpose library of reusable functionality. Most applications make some use of common functionality such as for logging or a specialized set of data handling, or like in our case, general purpose string handling. To build a new component, we start with a new project. Right-click on the Solution, and select Add, New Project. Select the desired language, then select Class Library ( .NET Framework) as the template. Give the project a general name. Don't use the solution prefix such as ACM if this library may be used by other applications. Since our fictitious company name is Acme, let's just call it Acme.Common. The first class in our component will handle strings, so let's rename the Class1 file to StringHandler, and select Yes to rename the class. Ensure the class is set to public so it can be accessed from outside the component. Now we write our InsertSpaces method. I'll paste the code, and we can talk through it. The method is public, so it can be used by any other component. It returns a string, and it takes in the string to process. The method initializes a result variable, which will be our return value. It skips processing of the source string if it's null or empty or other whitespace. If the source string contains something, it loops through each letter in the string looking for uppercase. If it finds an uppercase letter, it inserts a space and continues. Since code in this component could be reused throughout this application and other applications, unit testing is crucial. So our next step is to write the unit tests.

Testing the Reusable Component
In this demo, we write the unit tests for our reusable component. Because the code we are testing is in a new project, we'll create a new test project for it. Right-click on the Tests folder, and select Add, New Project. On the left, select the desired language and then Test. Then select the Unit Test Project from the list of templates. We'll name it Acme.CommonTest. And be sure to put it in our Tests folder. Next, we'll set a reference to the Acme.Common component so that tests can access the component classes. Right-click on References, Add Reference, Select Projects Solution, and check Acme.Common. Rename the UnitTest file StringHandlerTest, and select Yes to rename the class. Now we are ready to write our unit tests. Our first unit test is for a valid example. I'll paste the code, and we can talk through it. In the Arrange, we set the source string and expected result, then create the instance of our StringHandler class. Use the quick action to define the appropriate using statement. We act by calling the InsertSpaces method, passing in the source string. Then we Assert the expected matches our actual result. Spoiler alert; our test is going to fail. Did you catch it when we walked through the InsertSpaces code? Let's run the test and see. Open the Test Explorer, and pin it. Right-click on the new test project, and select to run the tests. Yep, it failed. Navigate down to our new InsertSpacesTest to see the details. Our code inserted a space before the first uppercase letter as well. Looking back at the StringHandler class, we could address that by adding code to check for the first letter, or we could just trim spaces from the result. Let's try the test again, and it passes. Going back to the test project, let's add another test to the StringHandlerTest class. This time we'll test if the input string already has spaces, that we don't add another space. In the Arrange, we set the source with an existing space. We expect that the result won't add another space. Then we create the instance of our StringHandler class. We act by calling the InsertSpaces method, passing in the source string. Then we Assert the expected matches our actual result. Do you think this one will pass? Let's run it and see. This one failed as well. Looking closely at the result, we can see that our code inserted an extra space. Going back to the StringHandler class, we could fix this in several ways. We could remove any spaces in the string before we start, but that may produce invalid results if the letter after the space is not uppercase. We could add code to check for a space, and then skip check in the next letter, or we could simply trim off any extra spaces before we add a space. Let's try running all our tests. And they all pass. Consider adding several more tests to cover other common scenarios such as null or empty strings, long strings, short strings, all uppercase strings, and so on. At this point, let's assume we've written those tests, and they all pass. Then it's time to use this component.

Using the Reusable Component
A reusable component is not very useful unless, of course, it's reused. In this demo, we walk through how to reuse a reusable component. Looking at the Product class, we want to remove spaces from the ProductName, so we want to use our new reusable component from our Product class. First, we need to set a reference to the reusable component. In the ACM.BL project, right-click on the References node and select Add Reference. Ensure that Projects is selected on the left, and check Acme.Common on the right. Our ACM.BL project can now use any public class from the common component. In the ProductName getter, create an instance of the StringHandler class. Use the quick action to add the appropriate using statement. We can then use that instance to call the InsertSpaces method, passing in our backing variable. We return the result. Now the ProductName provided by this class will always insert appropriate spaces in the name. And if the code must also store the name without spaces, we could add a remove spaces method to our common component and call it from the setter. But let's step back for a moment, and look at this code. Why do we need to create an instance? The StringHandler class does not maintain state. It has no properties. Wouldn't it be easier to use if we could just call this method without first creating the instance? The good news is that we can. That's what static classes are for.

Static Classes
When creating a method in a normal class, define the method signature in the class, and implement the method body. We call the method by creating an instance of the class using the new keyword and using that instance to call the method, passing in any required parameters. This is how we have the code now, but there is another way. A static class is a class that cannot be instantiated. That means we can't create an instance of it using the new keyword. Because there is no instance, we access the members of a static class using the class name. The syntax is then more concise because we don't have to create the instance first. Properties and methods in a static class must also be declared static. A static class is often used as a container for utility methods that don't require instant state. Our StringHandler class is definitely designed to be a container for utility methods, so we can change it to be a static class by adding the static keyword. Its methods must also then be static. We call the method directly using the class name. No instance is required. Let's try out the static keyword. We are looking at the StringHandler class. To make this class a static class, we add the static keyword to the class definition. As soon as we do, we see an error; can't declare instance members in a static class. This is telling us that the members must also be static. We make the InsertSpaces method static by adding the static keyword to the method definition. Looking at the error list, we now have even more errors. That's because the code currently uses the new keyword to create an instance of the class. Now that the class is static, we can no longer use the new keyword. Let's start with the Product class. We don't need to create the instance, we instead call the static method using the class name. The code in the getter is now simplified. Cool. We can't forget the unit tests, so let's fix them as well. Remove the code to create the instance here and here. Then call the method using the class name. Let's run all the tests to ensure all is well. And they all pass. Yay. Static classes are great, but use them sparingly. If you need instances, don't use the static keyword. Classes in the business layer, for example, need to track data for each instance. Customer A has one set of data, customer B has a different set of data, so having an instance is required. Limit the use of static classes to general purpose support classes. Now, do we want to take our utility methods a step further? Yes, yells the crowd. Let's extend the concept of static methods with extension methods.

Extension Methods
An extension method allows us to add methods to any existing type without the source code of the type, without inheritance, without recompiling, without any changes at all to the original type. Since we aren't modifying the original type, extension methods are great for adding methods to .NET types such as string. Adding methods to a .NET type means that the type appears in IntelliSense with all the built-in methods for that type. From the perspective of the code using the method, it looks like the method is a member of the extended type. Only static methods in static classes can be extension methods. Wouldn't it be cool if our InsertSpaces method existed as a method on the .NET string class? It would then appear in IntelliSense as just another string method like IndexOf or Length. To change our current static InsertSpaces method to an extension method, we simply add the this keyword before the first parameter. The method then becomes an extension method on the class defined in that first parameter. In this example, that type is string. Then, instead of calling the method using our class name, we call it using the string itself. In this example, we want to InsertSpaces into the ProductName string, so that's the string we call it with, just like calling other string methods such as trim. This syntax makes it so easy to read. Very cool. Let's extend the .NET string class with our InsertSpaces method. Looking at the StringHandler, changing our static InsertSpaces method into an extension method is very easy. An extension method must reside in a static class. Yep, this class is already static. The extension method itself must be static. Yep, this method is already static. Then add a this in front of the first parameter of the method. This parameter then no longer represents a parameter passed to the method, rather, it represents the type being extended. In our case, it is extending the string class. And to be a good citizen, let's add a documentation comment to our method for IntelliSense to use. Type ///, and our comment is generated. In the comment, describe the purpose of this method. Inserts spaces before each capital letter in a string. Looking at our error list, notice that this does not break any of our existing code. The method can still be called like a static method, but now it can also be called as a method on the extended class. Let's change the Product class getter. We can now call the method directly on the string itself. Type _productName., and notice that our InsertSpaces method now appears in the list with the .NET string methods. And we see our documentation comment. Since we are now calling the method using the string instance, we don't need to pass in the string as a parameter. To see this in action, let's make the same change to the unit tests. In the StringHandler test, our string is source, so we call the InsertSpaces on the source string. Going back to Test Explorer, rerun the tests, and they all pass. Another benefit of extension methods is discoverability. If another developer is looking for a way to insert spaces, when the developer types source., the extension methods appear in IntelliSense. No need to hunt around for or remember the name of the class in the component. This might help your reusable code get reused more often. Now that we've looked at static and extension methods, which should we use when?

Static Method vs. Extension Method
When creating reusable methods and reusable classes within a reusable component, when should we define a simple static method, and when should we instead define an extension method? To make this choice, consider the following questions; is the primary parameter to the method an instance? Does the method logically operate on that instance? Is it desirable for the method to appear in IntelliSense for that type? If the answer to these questions is yes, then consider defining an extension method. Otherwise, the static method will do. Let's consider these questions with our InsertSpaces method. Is the primary method parameter an instance? Yes, it's an instance of a string. Does the method logically operate on that instance? Yes, it inserts spaces into that string. Is it desirable for the method to appear in IntelliSense for that type? Yes, InsertSpaces makes sense as a member of the string class and should appear in IntelliSense for any string. Based on these criteria, it makes sense that we made our InsertSpaces method an extension method. When determining whether a static method should instead be an extension method, ask yourself these questions. Now let's finish off this module with some checklists we can use as we build reusable components.

Checklists and Summary
In this module, we walked through how to build a reusable component. Create a separate project for each reusable component. For example, you may want one reusable component for common UI functionality, one as a more general purpose library, and one specifically for accessing a data store. Build a library of general purpose methods in the component. Organize the method's logically into classes. A StringHandler class contains string methods. A logging service contains logging methods, and so on. Reuse the component in any application you build. When building reusable components, we often define static classes. A static class is a class that cannot be instantiated. A static class is sealed, meaning it can't be extended through inheritance. Define a static class using the static keyword. Use a static class to organize utility methods. Every method in a static class must be static. Define a method as static with a static keyword. Access a static member with the class name. Use static methods to create reusable utility methods. Sometimes, we may want to make our static method an extension method. An extension method adds a method to an existing type without modifying the original type. The method must be static. Define a method as an extension method by adding this to the first parameter. The type of that first parameter is then the type that is extended. In this example, we extend the string type. Access an extension method using the extended class instance. In this example, we extend string, so we use the string instance to access the method. By building a reusable library of general purpose classes, you have a reusable component that you and your team can use for your current and future projects. Now let's look at one more way to leverage reuse; defining interfaces.

Understanding Interfaces
Introduction
Interfaces provide a clean way to work with a set of classes in a common manner. Welcome back to Object-Oriented Programming Fundamentals in C#, from Pluralsight. My name is Deborah Kurata, and this module is all about interfaces. From Wikipedia: In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information. The exchange can be between software, computer hardware, peripheral devices, humans, and combinations of these. Hence, the boundary between the user in an application is called the user interface. In web development, the boundary between a back end that provides services and the front-end clients requesting those services is called a web API, or web application programming interface. And in an object-oriented application, the boundary between each class and the rest of the application is called a class interface. But what exactly is a class interface? In this module, we begin by examining what a class interface is. Then we define our own interface and implement that interface in our entity classes. Lastly, we cover how to leverage interface- based polymorphism to build more generalized and reusable code. Let's get started.

Class Interface
Every class has a basic class interface comprised of its public members. Each of the public properties and methods are part of that interface. By declaring a property or method as public in the class, that member automatically becomes part of that class interface. There is no special code, keyword, or configuration required. Other parts of the application communicate with this class through this interface. Access the public property to work with data from the class. Call a public method to execute code in the class. So a class interface is basically what a class looks like to the rest of the application. Each class we've created so far in this course has a class interface defined by its public properties and methods. And we've been using that interface to work with our classes. Diagrammatically, interfaces are sometimes shown with a connector that looks like a lollipop attached to the class. The idea is that other classes connect to this class via this connector. In this example, the interface for our Customer class includes the LastName, FirstName, other defined public properties, and a Validate method. And the interface for our Product class includes the ProductName, CurrentPrice, other defined public properties, along with a Validate method. In C#, we can define additional interfaces for our classes. We define an interface using the interface keyword. By convention, the interface name begins with an I. Like a class, the interface defines a set of related properties and methods, but unlike a class, an interface does not provide any code for those properties and methods, only the signature. Any class that implements the interface provides the code for each property and method specified in the interface. Say we want to add a general purpose logging service to our application. We define an ILoggable interface with a Log method. If we want to log both customer and product information, we implement the ILoggable interface in both classes. Each class then provides the code for every property and method in the interface. In this example, there is only one method, so each class implements that Log method. The application can work with a class through any of its interfaces. For example, the application can work with the Customer class through its basic class interface, shown in blue, to access the LastName or FirstName properties or call the Validate method. Or the application can work with a customer class through the ILoggable interface, shown in purple. The application code can use this interface and call the Log method on the customer. Same with the Product class. Code can access the class through its basic class interface or through the ILoggable interface. Let's illustrate these concepts further with metaphors.

Interface Metaphors
There are several metaphors to aid in understanding interfaces. Think of an interface as defining a role that an object can play. Consider a person. A person has a default set of properties and behaviors that comprise their default person interface. Depending on the person, they may also have the IParent role and have parental properties and behaviors. They may have the IPartner role and the IEmployee role. Anyone can interact with this person through one of their roles. In our scenario, the Customer class has its default class role and its ILoggable role to log out customer information. Or to say it another way, an object performs the logging role through its ILoggable interface. Another common metaphor for understanding interfaces is a contract. Think of an interface as a contract that specifies the set of properties and methods that must be available on any implementing object. In this example, our ILoggable contract has only one method, Log. If the customer class implements the ILoggable interface, it is contractually obligated to implement the Log method. Any other part of the application can depend on that contract. That means we can write generalized code that works with potentially unrelated classes through a common interface and be guaranteed that the interface methods are implemented. Now let's walk through a scenario to better understand how to leverage reuse through interfaces.

Setting up the Demo
A common requirement in many applications is to log important information. We can log information helpful for resolving bugs. If a bug occurs, the support team can look at the log to determine the current application's state and what the system was doing when the bug occurred. We can log information for security purposes. System administrators can identify who did what when. We can log information for data analysis, which features of the system are used most often. There are many different ways we can build logging into our application, including buying third-party products. For our example, we'll create our own logging mechanism. We've already created a reusable library component we called Acme.Common. We'll create a general purpose logging service in that component. The service will write the logging information to a log file, but how will this service know what information to log? The required information is different for each class. We need each class to be responsible for defining what it wants logged to the log file. To accomplish our objective, let's add a Log method to both our Customer and Product classes. Here we are back in Visual Studio and looking at the Customer class. Let's add a Log method. We could add a method that looks like this using string concatenation to build up the string to log, but that's a bit long and cumbersome. Let's shorten it up to this. Cool. This syntax leverages the expression bodied method feature that uses a lambda operator to reduce the code for a one-line method. It also makes use of the interpolated string syntax. Prefixing the string with a dollar symbol allows us to write the string using placeholders for our data values instead of string concatenation. Comparing the syntax, you'll see that it is equivalent to the longer form. Now let's add a similar Log method to our Product class using an expression bodied method and an interpolated string. Next, let's create a logging service class in the Acme.Common component. Right-click on the Acme.Common project, and select Add, Class. Name that class LoggingService. We want the class to be public so it can be accessed from anywhere in the application and static so we don't have to instantiate it. In that class, let's create a public method for the logging, and call it WriteToFile. Because it is a utility method, we'll make it static. And since it doesn't return anything, we'll set the return type to void. We pass in a list of all of the objects to log. Hmmm, what kind of list is this? Well, we could define just a list of type Object, then we can put anything in the list. Now we want to loop through each item and call its Log method. We can then write the results into our file. For our purposes, we'll just write to the console for now. But when I type item., only the members from the Object class appear. Attempting to call the Log method doesn't work. Now what? Any ideas? Well, we finally come back to the purpose of this module. Let's define an interface. We could then implement that interface in each class and access each instance here using that common interface. Let's comment this line out for now and define an interface.

Defining an Interface
An interface specifies only the definition or signature of the properties and methods, that is, it defines the name and data type for each property and the name and return value for each method along with the type and order of the method parameters. The interface does not include any implementation. There is no code in an interface, only signatures. The implementation is provided by the class that implements the interface. To define an interface, add a new interface item to the project. By convention, we prefix the interface name with an I. Be sure to specify the public access modifier so any class can use the interface. Then define the members of the interface by adding the property, method, event, or indexer signatures. Note that an interface cannot define constants, fields, operators, or constructors. There is no need for an access modifier on the members. All members of an interface are public. An interface does not provide an implementation, so there is no code in the interface, only the property and method signatures. Let's build an interface to support the logging feature. An interface is normally created in its own file, similar to a class. We'll define the interface as part of the Acme.Common project, so it can be used by any component or application. Right-click on the Acme.Common project, and select Add, New Item. Pick the interface template. Following common conventions, interfaces begin with the letter I, and the Interface name reflects its purpose. In this case, we'll call it ILoggable. Any class that implements this interface becomes loggable. Be sure to make the interface public. We only want one method, Log. The Log method returns a string containing the information to log. We could add any number of other members, but that's all we need. Notice that we don't add any curly braces or any code to the Log method and terminate its signature with a semicolon. Once an interface is defined, it can be implemented in any class that wants to take on the loggable role or support the loggable contract. The implementation is specified in the class that implements the interface. Let's see how that works.

Implementing an Interface
Implementing an interface in a class requires two steps. First, add the interface to the class signature. Insert a colon and the name of the interface. The class is now set to implement the interface. Separate multiple interfaces with commas, then implement every member of the interface. That involves writing code for every property, method, event, or indexer specified in that interface. The member must be public, non-static, and have the same name and signature as the interface member. By default, a class always has its basic class interface. A class can implement any number of additional interfaces. Implementing an interface essentially adds the lollipop to the class. For example, if the Customer class implements the ILoggable interface, it gets another lollipop. If it implemented an IEmailable interface, that would be another lollipop. Any code in the application can work with this class through its default role using any of the class interface members. Or work with this class through its ILoggable role, calling the Log method. Or work through its IEmailable role, calling the Send method. Let's implement our ILoggable interface in our entity classes. Let's start with the Customer class. Implement the ILoggable interface by adding the interface to the class signature after the colon. Recall that EntityBase is the base class that the Customer class inherits from. Add a comma and the name of the interface. Note that all interfaces must be listed after any base class. Use the quick action to add the needed using statement. The ILoggable interface requires a Log method. We already have that method here. So that's it. Let's repeat this for the Product class. Implement the ILoggable interface by adding the interface to the class signature. The using statement's already here. We needed it when calling our InsertSpaces extension method. The ILoggable interface requires a Log method. We already have that method here. What if we didn't already have a Log method? Let's see what it would look like by implementing the ILoggable interface in the Order class. We again add the interface to the class signature. Use the quick action to add the needed using statement. Notice that the interface has an error; Order does not implement interface member ILoggable.Log. We know what's causing this. When we implement an interface, we must add code for each of its properties and methods. Visual Studio can do this for us. Use the quick action and select Implement interface. This automatically adds the signature for all of the members of the interface. We just need to provide the implementation. Now that we have multiple classes that use the ILoggable interface, we can fix up the logging service we started earlier by leveraging polymorphism.

Interface-based Polymorphism
Recall that polymorphism means many shapes. In object-oriented programming, that means that a method can have the same signature, but different implementations in different classes. Earlier in this course, we leveraged inheritance-based polymorphism. We defined a Validate method in the EntityBase class and overrode it in our derived entity classes. Any code that calls the Validate method executes the correct shape of that method based on the type of object that called it. We can also leverage polymorphism through interfaces. At this point, our Log method is polymorphic. It has many shapes. One shape in the Customer class logs customer information. Another shape in the Product class logs product information, and so on. We could have dozens of shapes of the Log method. Any code that calls the Log method executes the correct shape of that method based on the type of object that called it. Let's see how we can take advantage of interface-based polymorphism. Here is the LoggingService class. When we last saw this class, we had defined a list of items to log. Those items could include customer instances or product instances, so we declared a list of objects so that we could put both customers and products on the list. Now that both classes implement the same interface, we can use the interface as the type to strongly type our list. Let's change Object to ILoggable. This allows us to work with each item in the list through its ILoggable interface. When we hover over item, we see that it is of type ILoggable, and when we type item., we see the object methods and our Log method, so we can call it to perform our logging. Our generalized logging code does not need to know anything about any of our entity or other classes. It just requires any class that wants to participate in logging implement the ILoggable interface. Then the LoggingService provides that logging, calling the class unique shape of the Log method to obtain the data to log. Think about how useful this would be in any common code. Let's try out our logging service with a unit test. I've created this test under the Tests folder in the Acme.CommonTest project in the LoggingServiceTest code file. The Arrange section creates a list of changed items. It creates a customer with a set of values and adds it to the list. It then creates a product with a set of values and adds it to the list. Since we implemented ILoggable in the Order class, we could add an order here as well. The Act section calls the WriteToFile method in the LoggingService. We may want to consider refactoring the WriteToFile so we can inspect the string written to the file for easier testing. We would then have a value to assert. Or if the code was actually writing to a file, in the Assert we could open the file to validate the result. But for now, we can use the output link to view the result. Let's run the test. Find the test in Test Explorer, right-click, and select Run Selected Tests. Click on the test to view the details, and click Output to view the result. It output our two changed objects. Nice. Looking again at our LoggingService WriteToFile method, we were able to call each item's Log method by leveraging interface-based polymorphism. Each class that implemented the ILoggable interface was contractually obligated to have a Log method. This loop knows which log method to call based on the underlying type of object. When it iterates through to a customer object, it calls the Log method in the Customer class through its ILoggable interface. If it's a product object, it calls the Log method in the Product class through its ILoggable interface, and so on. Now that we've seen polymorphism in action, let's identify the key benefits of interfaces in polymorphism. An interface provides strong typing when working with objects through that interface. We then get the benefit of IntelliSense and better syntax checking. An interface defines commonality among otherwise unrelated classes. The application can use that interface to work with the set of classes that implement the interface. Interface-based polymorphism aids in building generalized utility methods that can leverage class unique functionality. For example, our general purpose logging service logs unique data from unrelated classes by calling one of the many shapes of the Log method. This is why interfaces are used throughout .NET and in many design patterns. Now let's finish off this module with some checklists we can use as we define and implement interfaces.

Checklists and Summary
We discussed several metaphors for understanding interfaces. Interfaces define a role that an object can play in the operation of the application. Interfaces define a contract specifying the set of properties and methods that must be provided by any implementing object. Basically, an interface is comprised of a list of properties, methods, events, and iterators denoting the data and operations that an object can perform. Every class has a basic interface defined by the public properties and methods of the class. The application uses this interface to work with the class in its primary role, accessing its public properties, and calling its public methods. We can define any number of additional interfaces. Define an interface using the interface keyword. Specify the signatures of the interface members with no code. Any class can implement an interface. Implement an interface by adding it to the class signature after a colon. Define multiple interfaces separated by commas. The class must then write code for every property and method defined in that interface. Polymorphism means many shapes. In the context of interfaces, we specify a method name and an interface, and write code for that method in each class that implements the interface, giving that method its many shapes. This allows us to work with otherwise unrelated classes in a generalized, reusable way. Only one short module left.

Final Words and Next Steps
Introduction
C# is a modern, general purpose, object-oriented programming language. Now that you know more about object- oriented programming concepts, you can better leverage the features of C# to build well-crafted and testable applications. Welcome back to Object-Oriented Programming Fundamentals in C#, from Pluralsight. My name is Deborah Kurata, and the final words in this course include a brief recap and a look at next steps to further your study.

Recap
When given a specification for a feature or a new application, start by identifying the classes from the requirements or specification. Object-oriented programming represents the entities and concepts of an application as a set of classes. Each class has properties that define the data each object will manage. Each class has methods, which are the actions and behaviors that each object can perform. Then analyze the classes you identified and separate responsibilities as needed. Minimize coupling by ensuring each class has a single purpose. Maximize cohesion by reviewing the properties and methods of each class to confirm each one belongs to that class. Single-focus classes simplify maintenance and improve testability. No class is an island, so the next step is to look at relationships. The relationships between the classes define how the objects created from those classes work together to perform the operations of the application. Leverage reuse wherever possible. The power of object-oriented programming lies in its promise of reuse. By extracting commonality among a set of classes into a separate class, you have more reusable code. Extensive reuse of existing proven classes not only shortens development time, it also leads to more robust applications. There are several ways to achieve reuse, including extracting common functionality into a base class using inheritance. Reuse through a component library of general purpose classes and reuse through interfaces. This course also identified the four pillars, or characteristics, of object-oriented programming; abstraction, encapsulation, inheritance, and polymorphism. Abstraction describes an entity in simple terms, ignoring the irrelevant details. It reduces complexity by focusing only on what is important for the purpose of this specific application. Encapsulation allows for hiding the data and the implementation within the class. The data is stored in backing fields and accessible to the rest of the application through property getters and setters. The code is only accessed through the class interface. Inheritance allows derived, or child, classes to reuse all the code in the base or parent class. We created an EntityBase class that contained a standard set of properties and a Validate method. Each entity class then inherited from this EntityBase class to reuse its functionality. But in some cases, we don't want to reuse the base class functionality, so we leverage inheritance-based polymorphism by overriding the method. The idea behind inheritance-based polymorphism is that a base class can define a method and any derived class can override that method to provide its own definition and implementation, basically, providing its own shape for the method. Another way to leverage polymorphism is with interfaces. The idea behind interface-based polymorphism is that an interface can define a method, and any class can implement that interface to define its own code for that method, basically providing its own shape for the method. Generalized code can then access the appropriate shape based on the type of object that called it. Let's finish up this module with a look at next steps.

Next Steps
Object-oriented programming is the foundation of many current application development approaches. Now that you are familiar with the fundamentals, you can dive deeper into any of these topics. Here are some Pluralsight courses to help you take the next step in your learning journey. Defensive coding techniques help you write great, maintainable code and help you keep that code great after maintenance activities, multiple developers, and the ravages of time. Clean Code is a reader-focused development style that produces software that's easy to write, read, and maintain. Check out the C# Interfaces course to extend your knowledge of interfaces. If you are interested in more information about design patterns, continue with the Design Patterns On-Ramp course. For more information on best practices, check out C# Best Practices: Improving on the Basics or C# Best Practices: Collections and Generics. Congratulations. You have completed the journey through the fundamental principles and practices of object-oriented programming. Thanks for listening.